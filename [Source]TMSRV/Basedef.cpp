#include "stdafx.h"
#include <mbstring.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include "BaseDef.h"

#ifdef __ZONE_SERVER__
	#include "HTNew_Off.h"
	#include "TNDebug.h"
	#include "TNInfluenceMap.h"
	#include "HTParamMgr.h"
	extern CHTParameterMgr		g_ParamMgr;
	extern TNITEM_DATA			pItemData[MAX_ITEM_DATA];
	TNInfluenceMap		g_kInfluenceMap ;
#endif //__ZONE_SERVER__

#if defined(__ZONE_SERVER__) && defined(__MEMORYMANAGER__)

#ifndef _HTMEMORYMANAGER_H_
#include "HTMemoryManager.h"
#endif

#endif //__ZONE_SERVER__, __MEMORYMANAGER__

//	각국버전 메시지 테이블 
char  g_pMessageStringTable[MAX_STRING][128];

extern int	g_HeightWidth;
extern int	g_HeightHeight;
extern int	g_HeightPosX;
extern int	g_HeightPosY;
char		g_pEnglish[MAX_ENGLISH][3][SZNAME_LENGTH];
#define MH 1000

STRUCT_INITITEM		g_pInitItem[MAX_INITITEM];
int					g_dwInitItem = 0;
STRUCT_ITEMLIST		g_pItemList[MAX_ITEMLIST];
char				g_pServerList[MAX_SERVERGROUP][MAX_SERVERNUMBER][64];
unsigned			g_pServerListBin[MAX_SERVERGROUP][MAX_SERVERNUMBER];
unsigned	short	g_pServerListPort[MAX_SERVERGROUP][MAX_SERVERNUMBER];
STRUCT_SPELL		g_pSpell[MAX_SKILLINDEX];  // InitializeSkillData
//short				pHeightGrid[MAX_GRIDY][MAX_GRIDX]; // 높이 정보, 단순히 이동이나 거리 계산시에만 쓰인다.
//WORD				g_pAttribute[MAX_GRIDY][MAX_GRIDX]; // cell의 속성
TNCELL              g_krgCell[MAX_GRIDY][MAX_GRIDX] ;



// 색적 table
int  g_iHostileTable[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 
	14,	14,	14,	14,	14,	14, 14, 14,	14,	14,	 0,	14,	14,	 5,	14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,  // 주신 선택하지 않은 Player	, 0
	14,	 0,	14,	 5,	14,	 0, 14, 14,	14,	14,	 0,	14,	14,	 5,	14,	14,	14,	14,	 0,	14,	14,	14,	14,	14,	14,	 0, // Brahma Player				, 1
	14,	14,	 0,	 5,	14,	14,  0, 14,	14,	14,	 0,	14,	14,	 5,	14,	14,	14,	14,	 0,	14,	14,	14,	14,	14,	14,	 0, // Vishnu Player				, 2
	 5,	 5,	 5,	 0,	 5,	 5,  5,  5,	 5,	 5,	 0,	14,	14,	 5,	 5,	 5,	 5,	 5,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Hunter						, 3
	14,	14,	14,	 5,	 0,	14, 14,  0,	14,	14,	 0,	14,	14,	 5,	14,	14,	14,	14,	 0,	14,	14,	14,	14,	14,	14,	 0, // Siva   Player				, 4
	14,	 0,	14,	 5,	14,	 0, 14, 14,	 5,	 5,	 0,	 5,	 5,	 5,	14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Soldier				, 5
	14,	14,  0,	 5,	14,	14,  0, 14,	 5,	 5,	 0,	 5,	 5,	 5,	14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Soldier				, 6
	14,	14, 14,	 5,	 0,	14, 14,  0,	 5,	 5,	 0,	 5,	 5,	 5,	14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva	  Soldier				, 7
	 5,	 5,	 5,	 5,	 5,	 5,  5,  5,	 0,	 5,	 0,	 5,	 5,	 5,	 5,	 5,	 5,	 5,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	14,	14,	14,	14,	14,	 5,  5,  5,  5,	 0,	 0,	 5,	 5,	 5,	14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	14,	 0, // Aggresive					, 9
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 5,	 5,	 5,	 5,	 5,	 5,  5,  5,	 5,	 5,	 0,	 0,	 5,	 5,	 5,	 5,	 5,	 5,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim1(Neutral)				, 11
	14,	14,	14,	14,	14,	 5,  5,  5,	 5,	 5,	 0,	 5,	 0,	 5,	 5,	 5,	 5,	 5,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	14,	14,	14,	14,	14,	14, 14, 14,	14,	14,	 0,	14,	14,	 0,	14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	14, 14, 14,	14,	14,	14, 14, 14,	14,	14,	 0,	14,	14, 14,	 0,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	14, 14, 14,	14,	14,	14, 14, 14,	14,	14,	 0,	14,	14, 14,	14,	 0,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	14, 14, 14,	14,	14,	14, 14, 14,	14,	14,	 0,	14,	14, 14,	14,	14,	 0,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	14, 14, 14,	14,	14,	14, 14, 14,	14,	14,	 0,	14,	14, 14,	14,	14,	14,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17	
	 0,  0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // NPC 18							, 18
	14, 14,	14,	14, 14,	14, 14, 14, 14, 14,	 0,	14,	14, 14,	14,	14,	14,	14,	 0,	 0,	14,	14,	14,	14,	 0,	 0, // Castle	19					, 19
	14, 14,	14,	14, 14,	14, 14, 14, 14, 14,	 0,	14,	14, 14,	14,	14,	14,	14,	 0,	14,	 0,	14,	14,	14,	14,	 0, // siege1	20					, 20
	14, 14,	14,	14, 14,	14, 14, 14, 14, 14,	 0,	14,	14, 14,	14,	14,	14,	14,	 0,	14,	14,	 0,	14,	14,	14,	 0, // siege2						, 21
	14, 14,	14,	14, 14,	14, 14, 14, 14, 14,	 0,	14,	14, 14,	14,	14,	14,	14,	 0,	14,	14,	14,	 0,	14,	14,	 0, // siege3						, 22
	14, 14,	14,	14, 14,	14, 14, 14, 14, 14,	 0,	14,	14, 14,	14,	14,	14,	14,	 0,	14,	14,	14,	14,	 0,	14,	 0, // siege4						, 23
	 0,  0,	 0,	 0,  0,	 0,  0,  0,  0, 14,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	14,	14,	14,	14,	 0,	 0, // guards of the Castle	 24		, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved				 25		, 25
//	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br Cl1 Cl2 Cl3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Friend, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.



// 일반 zone friend table
// 일반 zone enemy table
// RvR zone friend table
// RvR zone enemy table

// 일반 zone에서 PC의 경우 enemy는 모든 것이 될 수 있다. 우호관계(0)을 제외한 모든 것
// 일반 zone에서 PC의 경우 friendly의 경우는 같은 PC(or PC계열)를 말한다. 아래의 표에서는 적대관계(10초과)를 제외한 모든 것이다.
// 일반 zone에서 Monster의 경우 friendly의 경우는 우호(0)인 것들만을 말한다.
// 일반 zone에서 monster의 경우 enemy 경우는 적대 관계(10초과)를 가지는 것들을 말한다.

//if( g_irgEnemyTable[자신주신][타겟주신] ) continue ; 와 같은 구문을 위해, 관계값을 거꾸로 입력했다.
//참이면 0을, 거짓이면 1을 입력해놓은 것이다.

// 일반 zone enemy talbe
// PC는 자신과 party를 제외한(이것은 client가 할 것이다.) 모든 다른 PC가 적이다. PK 버튼 on/off에 따라서 table을 나눌 수도 있다.
int  g_irgEnemyTablePKOn[MAX_CLAN][MAX_CLAN]= // g_irgEnemyTablePKOn[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // 주신 선택하지 않은 Player	, 0
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Brahma Player				, 1
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Vishnu Player				, 2
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Hunter						, 3
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Siva   Player				, 4
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Brahma Soldier				, 5
	 0,	 0,  0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Vishnu Soldier				, 6
	 0,	 0,  0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Siva	  Soldier				, 7
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim0(Neutral)				, 11
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // NPC							, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 1,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 0,	 0,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 1,	 0,	 0, // siege4						, 23
	 1,	 1,	 1,	 0,  1,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 1,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
//	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br Cl1 Cl2 Cl3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv

}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.


int  g_irgEnemyTablePKOff[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // 주신 선택하지 않은 Player	, 0
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Brahma Player				, 1
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Vishnu Player				, 2
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Hunter						, 3
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Siva   Player				, 4
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Brahma Soldier				, 0
	 1,	 1,  1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Vishnu Soldier				, 6
	 1,	 1,  1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 1,	 0, // Siva	  Soldier				, 7
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim0(Neutral)				, 11
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Reserved						, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 1,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 1,	 0,	 0,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 1,	 0,	 0, // siege4						, 23
	 1,	 1,	 1,	 0,  1,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 1,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
 //	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br   C1  C2  C3 Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.


// 일반 zone friend talbe
// PC는 다른 PC와는 friend관계이고 몬스터와는 보통 적대관계이다.(PC편인 몬스터는 제외)
int  g_irgFriendTable[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // 주신 선택하지 않은 Player	, 0
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Player				, 1
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Player				, 2
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Hunter						, 3
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva   Player				, 4
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Soldier				, 5
	 1,	 1,  1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Soldier				, 6
	 1,	 1,  1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva	  Soldier				, 7
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim1(Neutral)				, 11
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 1,	 0,	 1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 0,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 0,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 0,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 0,	 0,	 0,	 1,	 0,	 0,  0,  0,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Reserved						, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 0,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 1,	 0,	 1,	 1,	 1,	 1,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 0,	 0,	 0,	 1,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 0,	 0,	 1,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 0,	 1,	 0, // siege4						, 23
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 0,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
 //	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br  C1  C2  C3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.



// RvR zone enemy talbe
// PC는 모든 것이 적이다. PK 버튼 on/off에 따라서 유동적이다.
int  g_irgEnemyTableRvR[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 1은 friend, 0은 enemy
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // 주신 선택하지 않은 Player	, 0
	 0,	 1,	 0,	 0,	 0,	 1,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Player				, 1
	 0,	 0,	 1,	 0,	 0,	 0,  1,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Player				, 2
	 0,	 0,	 0,	 1,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Hunter						, 3
	 0,	 0,	 0,	 0,	 1,	 0,  0,  1,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva   Player				, 4
	 0,	 1,	 0,	 0,	 0,	 1,  0,  0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Soldier				, 0
	 0,	 0,  1,	 0,	 0,	 0,  1,  0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Soldier				, 6
	 0,	 0,  0,	 0,	 1,	 0,  0,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva	  Soldier				, 7
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim0(Neutral)				, 11
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Reserved						, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege4						, 23
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
 //	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br  C1  C2  C3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.

// RvR zone friend talbe
// PC는 다른 PC와는 friend관계이고 몬스터와는 보통 적대관계이다.(PC편인 몬스터는 제외)
int  g_irgFriendTableRvR[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 1은 enemy, 0은 friend
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // 주신 선택하지 않은 Player	, 0
	 1,	 0,	 1,	 1,	 1,	 0,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Player				, 1
	 1,	 1,	 0,	 1,	 1,	 1,  0,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Player				, 2
	 1,	 1,	 1,	 0,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Hunter						, 3
	 1,	 1,	 1,	 1,	 0,	 1,  1,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva   Player				, 4
	 1,	 0,	 1,	 1,	 1,	 0,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Soldier				, 5
	 1,	 1,  0,	 1,	 1,	 1,  0,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Soldier				, 6
	 1,	 1,  1,	 1,	 0,	 1,  1,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva	  Soldier				, 7
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim1(Neutral)				, 11
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Reserved						, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege4						, 23
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
 //	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br Cl1 Cl2 Cl3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.

// stronghold zone enemy talbe
// PC는 모든 것이 적이다.
int  g_irgEnemyTableStrH[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 1은 friend, 0은 enemy
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // 주신 선택하지 않은 Player	, 0
	 0,	 0,	 0,	 0,	 0,	 1,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Player				, 1
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Player				, 2
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Hunter						, 3
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva   Player				, 4
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Soldier				, 0
	 0,	 0,  0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Soldier				, 6
	 0,	 0,  0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva	  Soldier				, 7
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim0(Neutral)				, 11
	 0,	 0,	 0,	 0,	 0,	 1,  1,  1,	 1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 1,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Reserved						, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege4						, 23
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
 //	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br   C1  C2  C3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.

// stronghold zone friend talbe
// PC는 다른 PC와는 friend관계이고 몬스터와는 보통 적대관계이다.(PC편인 몬스터는 제외)
int  g_irgFriendTableStrH[MAX_CLAN][MAX_CLAN]= // g_iHostileTable[색적몹][검색된몹], 이순서를 꼭 지켜야 한다.
{//  따라서 열은 색적몹, 행은 검색된몹이다. 1은 enemy, 0은 friend
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // 주신 선택하지 않은 Player	, 0
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Player				, 1
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Player				, 2
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Hunter						, 3
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva   Player				, 4
	 1,	 0,	 1,	 1,	 1,	 0,  1,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Brahma Soldier				, 5
	 1,	 1,  0,	 1,	 1,	 1,  0,  1,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Vishnu Soldier				, 6
	 1,	 1,  1,	 1,	 0,	 1,  1,  0,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Siva	  Soldier				, 7
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Neutral						, 8
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,  0,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Aggresive					, 9
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // GM							, 10
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 0,	 1,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim1(Neutral)				, 11
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 0,	 0,	 0,	 1,	 0,	 1,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Victim2(Aggressive)			, 12
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,	 0,	 1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Berserker					, 13
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 0,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold1(like a player)	, 14
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 0,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold2(like a player)	, 15
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 1,	 0,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold3(like a player)	, 16
	 1,	 1,	 1,	 1,	 1,	 1,  1,  1,	 1,	 1,	 0,	 1,	 1,  1,	 1,	 1,	 1,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Stronghold4(like a player)	, 17
	 0,	 0,	 0,	 0,	 0,	 0,  0,  0,	 0,	 0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Reserved						, 18
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // Castle						, 19
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege1						, 20
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege2						, 21
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege3						, 22
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // siege4						, 23
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // cst monster					, 24
	 0,	 0,	 0,	 0,  0,	 0,  0,  0,  0,  0,	 0,	 0,	 0,  0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0,	 0, // reserved						, 25
 //	P0  P1  P2  HT  P3  M1  M2  M3  Ne  Ag  GM, Vt1 Vt2 Br Cl1 Cl2 Cl3  Cl4 NPC Cst sg1 sg2 sg3 sg4 cst2 rv
}; // 14:Aggressive, 5:Neutral, 0:Same clan, 5이면, 선공은 안하지만 반격은 한다. 0이면 아예 반격도 하지 않는다.


int g_pSkillPatternTable[eSklPtrn_Count][eSklPtrn_Size] =
{
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	// default skill							0
	// 보조1
	0, 2, 0, 0, 0, 0, 0, 2, 0, 0,	// 보조1을 20% 사용							1
	0, 0, 2, 0, 0, 0, 2, 0, 0, 0,	// 보조1을 20% 사용							2
	0, 2, 0, 0, 0, 2, 0, 0, 2, 0,	// 보조1을 30% 사용							3
	0, 0, 2, 0, 2, 0, 0, 2, 0, 0,	// 보조1을 30% 사용							4
	0, 2, 0, 0, 0, 2, 0, 0, 0, 2,	// 보조1을 30% 사용							5
	0, 0, 2, 0, 0, 2, 0, 2, 0, 2,	// 보조1을 40% 사용							6
	0, 2, 0, 0, 2, 2, 0, 0, 2, 0,	// 보조1을 40% 사용							7
	0, 0, 2, 0, 2, 0, 2, 0, 2, 0,   // 보조1을 40% 사용							8
	0, 2, 0, 2, 2, 0, 0, 2, 0, 2,   // 보조1을 50% 사용							9
	0, 2, 2, 0, 0, 2, 2, 0, 2, 0,	// 보조1을 50% 사용							10
	// 보조2
	0, 0, 3, 0, 0, 0, 3, 0, 0, 0,	// 보조2을 20% 사용							11
	0, 0, 0, 0, 3, 0, 0, 3, 0, 0,	// 보조2을 20% 사용							12
	0, 3, 0, 0, 3, 0, 0, 0, 3, 0,	// 보조2을 30% 사용							13
	0, 0, 3, 0, 0, 3, 0, 3, 0, 0,	// 보조2을 30% 사용							14
	0, 3, 0, 3, 0, 0, 0, 0, 0, 3,	// 보조2을 30% 사용							15
	0, 0, 3, 0, 0, 3, 3, 0, 0, 3,	// 보조2을 40% 사용							16
	0, 3, 0, 0, 3, 3, 0, 0, 0, 3,	// 보조2을 40% 사용							17
	3, 0, 0, 3, 0, 0, 3, 0, 3, 0,   // 보조2을 40% 사용							18
	3, 0, 0, 3, 3, 0, 0, 3, 0, 3,   // 보조2을 50% 사용							19
	0, 3, 0, 3, 0, 3, 0, 0, 3, 3,	// 보조2을 50% 사용							20
	// 보조1 + 보조2
	0, 2, 0, 0, 2, 0, 0, 3, 0, 0,	// 보조1을 20% 사용 + 보조2을 10% 사용		21
	0, 2, 3, 0, 0, 0, 2, 0, 0, 0,	// 보조1을 20% 사용 + 보조2을 10% 사용		22
	0, 2, 0, 0, 2, 3, 2, 0, 0, 0,	// 보조1을 30% 사용 + 보조2을 10% 사용		23
	0, 0, 2, 0, 2, 0, 0, 2, 0, 3,	// 보조1을 30% 사용 + 보조2을 10% 사용		24
	0, 2, 0, 3, 0, 2, 0, 0, 0, 2,	// 보조1을 30% 사용 + 보조2을 10% 사용		25
	2, 0, 3, 0, 0, 2, 0, 2, 0, 2,	// 보조1을 40% 사용 + 보조2을 10% 사용		26
	0, 2, 0, 0, 2, 3, 0, 2, 2, 0,	// 보조1을 40% 사용 + 보조2을 10% 사용		27
	3, 0, 2, 0, 2, 0, 2, 0, 2, 0,   // 보조1을 40% 사용 + 보조2을 10% 사용		28
	2, 0, 0, 2, 3, 0, 0, 3, 0, 2,   // 보조1을 30% 사용 + 보조2을 20% 사용		29
	0, 2, 3, 0, 0, 2, 3, 0, 2, 0,	// 보조1을 30% 사용 + 보조2을 20% 사용		30
	2, 2, 2, 2, 2, 2, 2, 2, 3, 2,	// 보조1을 90% 사용 + 보조2을 10% 사용      31
	2, 2, 2, 2, 2, 2, 3, 2, 2, 2,	// 보조1을 90% 사용 + 보조2을 10% 사용      32
	2, 2, 2, 2, 3, 2, 2, 2, 2, 2,	// 보조1을 90% 사용 + 보조2을 10% 사용      33

	0, 0, 0, 2, 0, 0, 0, 0, 0, 0,	// 보조1을 10% 사용							34
	0, 0, 0, 0, 0, 0, 2, 0, 0, 0,	// 보조1을 10% 사용							35
	0, 0, 0, 3, 0, 0, 0, 0, 0, 0,	// 보조2을 10% 사용							36
	0, 0, 0, 0, 0, 0, 3, 0, 0, 0,	// 보조2을 10% 사용							37
	0, 0, 2, 0, 0, 0, 3, 0, 0, 0,	// 보조1을 10% 사용, 보조2을 10% 사용		38
	0, 0, 0, 3, 0, 0, 0, 0, 2, 0,	// 보조1을 10% 사용, 보조2을 10% 사용       39
	0, 0, 2, 0, 3, 0, 0, 0, 0, 0,	// 보조1을 10% 사용, 보조2을 10% 사용       40

	0, 3, 0, 0, 3, 0, 0, 2, 0, 0,	// 보조1을 10% 사용 + 보조2을 20% 사용		41
	0, 3, 2, 0, 0, 0, 3, 0, 0, 0,	// 보조1을 10% 사용 + 보조2을 20% 사용		42
	0, 3, 0, 0, 3, 2, 3, 0, 0, 0,	// 보조1을 10% 사용 + 보조2을 30% 사용		43
	0, 0, 3, 0, 3, 0, 0, 3, 0, 2,	// 보조1을 10% 사용 + 보조2을 30% 사용		44
	0, 3, 0, 2, 0, 3, 0, 0, 0, 3,	// 보조1을 10% 사용 + 보조2을 30% 사용		45
	3, 0, 2, 0, 0, 3, 0, 3, 0, 3,	// 보조1을 10% 사용 + 보조2을 40% 사용		46
	0, 3, 0, 0, 3, 2, 0, 3, 3, 0,	// 보조1을 10% 사용 + 보조2을 40% 사용		47
	2, 0, 3, 0, 3, 0, 3, 0, 3, 0,   // 보조1을 10% 사용 + 보조2을 40% 사용		48
	3, 0, 0, 3, 2, 0, 0, 2, 0, 3,   // 보조1을 20% 사용 + 보조2을 30% 사용		49

} ;


char g_pAggrCorrect[eCls_MajorCount][eCls_MinorCount] =
{
	2, 1, 1, 0, 0, 0, 0, 0, // // class1 : 0
	3, 1, 1, 0, 0, 0, 0, 0, // 1차 전직, class1 : 1
	4, 3, 1, 0, 1, 1, 0, 0, // 2차 전직, class1 : 2
	4, 3, 1, 0, 1, 1, 0, 0, // 3차 전직, class1 : 3
} ;


char g_pFormation[MAX_FORMATION][MAX_PARTY][2]= 
{    1, 1, -1, 1,  1,-1, -1,-1,     1,0,
     1, 0, -1, 0,  2, 0, -2, 0,     3,0,
	 1, 1, -1, 1,  1,-1, -1,-1,     1,0,
     1, 0, -1, 0,  2, 0, -2, 0,     3,0,
	 2, 0,  0, 2,  1, 1,  0, 1,		1,0,
};

int	g_pDistanceTable[8][8]=
{	0,1,2,3,4,5,6,7,
	1,1,2,3,4,5,6,7,
	2,2,3,4,4,5,6,7,
	3,3,4,4,5,5,6,7,
	4,4,4,5,5,5,6,7,
	5,5,5,5,5,6,6,7,
	6,6,6,6,6,6,7,7,
	7,7,7,7,7,7,7,7
};

int g_pRefineTable[4][MAX_MAINREFINELEVEL] =
{
	 4,  8, 12, 16, 20, 24, 32, 40, 50, 60,  72,  84,	96,		108,	120,	// 한손(한손검, 한손도끼, 둔기, 단검, claw, 한손지팡이)
	 6, 12, 18, 24, 30, 36, 48, 60, 75, 90,  108, 126,	144,	162,	180,	// 양손(양손검, 양손도끼, 창, 양손 지팡이, 활)
	 9, 18, 27, 36, 48, 60, 75, 96, 126,162, 207, 252,  297,	342,	387,	// 방어구(상의, 하의, 방패)
	 3,  6,  9, 12, 16, 20, 25, 32, 42, 54,  69,  84,	99,		114,	129		// 방어구(투구, 신발, 장갑, 허리띠)
} ;


int g_pDirectionalTable[9][9] =
{
	4, 4, 4, 3, 3, 3, 2, 2, 2,
	4, 4, 4, 3, 3, 3, 2, 2, 2,
	4, 4, 4, 4, 3, 2, 2, 2, 2,
	5, 5, 4, 4, 3, 2, 2, 1, 1,
	5, 5, 5, 5, 0, 1, 1, 1, 1, // 4,4 is center
	5, 5, 6, 6, 7, 8, 8, 1, 1,
	6, 6, 6, 6, 7, 8, 8, 8, 8,
	6, 6, 6, 7, 7, 7, 8, 8, 8,
	6, 6, 6, 7, 7, 7, 8, 8, 8,
} ;

int g_pKnockbackTable[9][2] =
{
	1,  1, // 0
	1,  0,
	1, -1,
	0, -1,
   -1, -1,	
   -1,  0,
   -1,  1,
	0,  1,
	1,  1,
} ;


char g_pDetectEnemyTable[ePos_MaxPosCount][2] =
{
	  0,1,	  1,1,	  1,0,	 1,-1,	 0,-1,	-1,-1,	 -1,0,	 -1,1,	 -1,2,	  0,2,	  1,2,
	  2,2,	  2,1,	  2,0,	 2,-1,	 2,-2,	 1,-2,	 0,-2,	-1,-2,	-2,-2,	-2,-1, 	 -2,0,
	 -2,1,	 -2,2,	 -2,3,	 -1,3,	  0,3,	  1,3,	  2,3,	  3,3,	  3,2,	  3,1,	  3,0,
	 3,-1,	 3,-2,	 3,-3,	 2,-3,	 1,-3,	 0,-3,	-1,-3,	-2,-3,	-3,-3,	-3,-2,	-3,-1,
	 -3,0,	 -3,1,	 -3,2,	 -3,3,	 -3,4,	 -2,4,	 -1,4,	  0,4,	  1,4,	  2,4,	  3,4,
	  4,4,	  4,3,	  4,2,	  4,1,	  4,0,	 4,-1,	 4,-2,	 4,-3,	 4,-4,	 3,-4,	 2,-4,
	 1,-4,	 0,-4,	-2,-4,	-3,-4,	-4,-4,	-4,-3,	-4,-2,	-4,-1,	 -4,0,	 -4,1,	 -4,2,
	 -4,3,	 -4,4,	 -4,5,	 -3,5,	 -2,5,	 -1,5,	  0,5,	  1,5,	  2,5,	  3,5,	  4,5,
	  5,5,	  5,4,	  5,3,	  5,2,	  5,1,	  5,1,	  5,0,	 5,-1,	 5,-2,	 5,-3,	 5,-4,
	 5,-5,	 4,-5,	 3,-5,	 2,-5,	 1,-5,	 0,-5,	-1,-5,	-2,-5,	-3,-5,	-4,-5,	-5,-5,
	-5,-4,	-5,-3,	-5,-2,	-5,-1,	 -5,0,	 -5,1,	 -5,2,	 -5,3,	 -5,4,	 -5,5,	 -5,6,
	 -4,6,	 -3,6,	 -2,6,	 -1,6,	  0,6,	  1,6,	  2,6,	  3,6,	  4,6,	  5,6,	  6,6,
	  6,5,	  6,4,	  6,3,	  6,2,	  6,1,	  6,0,	 6,-1,	 6,-2,	 6,-3,	 6,-4,	 6,-5,
	 6,-6,	 5,-6,	 4,-6,	 3,-6, 	 2,-6,	 1,-6,	 0,-6,	-1,-6,	-2,-6,	-3,-6,	-4,-6,
	-5,-6,	-6,-6,	-6,-5,	-6,-4,	-6,-3,	-6,-2,	-6,-1,	 -6,0,	 -6,1,	 -6,2,	 -6,3,
	 -6,4,	 -6,5,	 -6,6,  -6,-7,   -6,7,	-5,7,	-4,7,	 -3,7,	 -2,7,	 -1,7,	 0, 7,
	 1,7,	 2, 7,	 3, 7,	 4,7,	 5, 7,	 6,7,	 7,7,	  7,6,    7,5,    7,4,    7,3,
     7,2,    7,1,    7,0,    7,-1,   7,-2,  7,-3,   7,-4,    7,-5,   7,-6,   7,-7,  -7,-7,
	 -6,-7,	-5,-7,	-4,-7,	-3,-7,	-2,-7,	-1,-7,	0, -7,	 1,-7,	2, -7,	 3, -7,	 4,-7,
	 5, -7,	 6,-7,   -7,7,   -7,6,   -7,5,   -7,4,   -7,3,   -7,2,   -7,1,    -7,0,  -7,-1,
     -7,-2, -7,-3,  -7,-4,  -7,-5,  -7,-6,  -7,8,	-6,8,	 -5,8, 	 -4,8,	 -3,8,	  -2,8,
	 -1,8,	 0, 8,	 1,8,	 2, 8,	 3, 8,	 4,8,	 5, 8,	  6,8,	  7,8,    8,8,   8,7,
     8,6,     8,5,   8,4,     8,3,    8,2,   8,1,     8,0,   8,-1,   8,-2,   8,-3,   8,-4,
     8,-5,   8,-6,  8,-7,   -8,-8,	-7,-8,	-6,-8,	-5,-8,	-4,-8,	-3,-8,	-2,-8,	-1,-8,
	 0,-8,	1,-8,	2, -8,	3, -8,	4,-8,	5, -8,	 6,-8,	 7,-8,	 8,-8,   -8,8,   -8,7,
     -8,6,   -8,5,   -8,4,   -8,3,   -8,2,   -8,1,   -8,0,  -8,-1,  -8,-2,  -8,-3,  -8,-4,
     -8,-5, -8,-6,  -8,-7, // 반지름 8까지
	 -9,9,	-8, 9,	-7, 9,	-6, 9,	-5, 9,	-4, 9,	-3, 9,	-2, 9,	-1, 9,	0, 9,	1, 9,
	 2, 9,	 3, 9,	 4, 9,	 5, 9,	 6, 9,	 7, 9,	 8, 9,	 9, 9,
	 -9,-9,	-8,-9,	-7, -9,	-6, -9,	-5, -9,	-4, -9,	-3, -9,	-2, -9,	-1, -9,	0, -9,	1, -9,	
	 2, -9,	3, -9,	4, -9,	5, -9,	6, -9,	7, -9,	8, -9,	9, -9,
	 -9,8, -9,7, -9,6, -9,5, -9,4, -9,3, -9,2, -9,1, -9,0, -9,-1, -9,-2, -9,-3, -9,-4, -9,-5,
     -9,-6, -9,-7, -9,-8, 9,8, 9,7, 9,6, 9,5, 9,4, 9,3, 9,2, 9,1, 9,0, 9,-1, 9,-2, 9,-3, 9,-4,
	 9,-5, 9,-6, 9,-7, 9, -8, // 반지름 9까지
	 -10,10,	-9,10,	-8, 10,	-7, 10,	-6, 10,	-5, 10,	-4, 10,	-3, 10,	-2, 10,	-1, 10,	0, 10,	1, 10,	
	 2, 10,	3, 10,	4, 10,	5, 10,	6, 10,	7, 10,	8, 10,	9, 10,	10, 10,
	 -10,-10, -9,-10, -8,-10, -7, -10, -6, -10,	-5, -10, -4, -10, -3, -10, -2, -10, -1, -10, 0, -10, 1, -10,	
	 2, -10, 3, -10,	4, -10,	5, -10,	6, -10,	7, -10,	8, -10,	9, -10,	10, -10,
	-10,9, -10,8, -10,7, -10,6, -10,5, -10,4, -10,3, -10,2, -10,1, -10,0, -10,-1, -10,-2, -10,-3,
    -10,-4, -10,-5, -10,-6, -10,-7, -10,-8, -10,-9, 10,9, 10,8, 10,7, 10,6, 10,5, 10,4, 10,3,
     10,2, 10,1, 10,0, 10,-1, 10,-2, 10,-3, 10,-4, 10,-5, 10,-6, 10,-7, 10, -8, 10, -9, // 반지름 10까지

	-11, 11,	-10 , 11,	-9 , 11,	-8 , 11,	-7 , 11,	-6 , 11,	-5 , 11,	-4 , 11,	-3 , 11,	-2 , 11,	-1 , 11,	0 , 11,	1 , 11,	2 , 11,	3 , 11,	4 , 11,	5 , 11,	6 , 11,	7 , 11,	8 , 11,	9 , 11,	10 , 11,	11 , 11,
	-11, -11,	-10 , -11,	-9 , -11,	-8 , -11,	-7 , -11,	-6 , -11,	-5 , -11,	-4 , -11,	-3 , -11,	-2 , -11,	-1 , -11,	0 , -11,	1 , -11,	2 , -11,	3 , -11,	4 , -11,	5 , -11,	6 , -11,	7 , -11,	8 , -11,	9 , -11,	10 , -11,	11 , -11,
	-11, 10,	-11, 9,	-11, 8,	-11, 7,	-11, 6,	-11, 5,	-11,4,	-11,3,	-11,2,	-11,1,	-11,0,	-11,-1,	-11,-2,	-11,-3,	-11,-4,	-11,-5,	-11,-6,	-11,-7,	-11,-8,	-11,-9,	-11,-10,
	11, 10,	11, 9,	11, 8,	11, 7,	11, 6,	11, 5,	11,4,	11,3,	11,2,	11,1,	11,0,	11,-1,	11,-2,	11,-3,	11,-4,	11,-5,	11,-6,	11,-7,	11,-8,	11,-9,	11,-10,

	-12, 12,	-11, 12,	-10, 12,	-9, 12,	-8, 12,	-7, 12,	-6 , 12,	-5 , 12,	-4 , 12,	-3 , 12,	-2 , 12,	-1 , 12,	0 , 12,	1 , 12,	2 , 12,	3 , 12,	4 , 12,	5 , 12,	6 , 12,	7 , 12,	8 , 12,	9 , 12,	10 , 12,	11 , 12,	12 , 12,
	-12, -12,	-11 , -12,	-10 , -12,	-9 , -12,	-8 , -12,	-7 , -12,	-6 , -12,	-5 , -12,	-4 , -12,	-3 , -12,	-2 , -12,	-1 , -12,	0 , -12,	1 , -12,	2 , -12,	3 , -12,	4 , -12,	5 , -12,	6 , -12,	7 , -12,	8 , -12,	9 , -12,	10 , -12,	11 , -12,	12 , -12,
	-12, 11,	-12, 10,	-12, 9,	-12, 8,	-12, 7,	-12, 6,	-12, 5,	-12,4,	-12,3,	-12,2,	-12,1,	-12,0,	-12,-1,	-12,-2,	-12,-3,	-12,-4,	-12,-5,	-12,-6,	-12,-7,	-12,-8,	-12,-9,	-12,-10,	-12,-11,
	12, 11,	12, 10,	12, 9,	12, 8,	12, 7,	12, 6,	12, 5,	12,4,	12,3,	12,2,	12,1,	12,0,	12,-1,	12,-2,	12,-3,	12,-4,	12,-5,	12,-6,	12,-7,	12,-8,	12,-9,	12,-10,	12,-11,


	-13, 13,  -12, 13,	-11, 13,	-10, 13,	-9, 13,	-8, 13,	-7, 13,	-6 , 13,	-5 , 13,	-4 , 13,	-3 , 13,	-2 , 13,	-1 , 13,	0 , 13,	1 , 13,	2 , 13,	3 , 13,	4 , 13,	5 , 13,	6 , 13,	7 , 13,	8 , 13,	9 , 13,	10 , 13,	11 , 13,	12, 13,  13 , 13,
	-13, -13,	-12, -13,  -11 , -13,	-10 , -13,	-9 , -13,	-8 , -13,	-7 , -13,	-6 , -13,	-5 , -13,	-4 , -13,	-3 , -13,	-2 , -13,	-1 , -13,	0 , -13,	1 , -13,	2 , -13,	3 , -13,	4 , -13,	5 , -13,	6 , -13,	7 , -13,	8 , -13,	9 , -13,	10 , -13,	11 , -13,  12, -13,	13 , -13,
	-13, 12,  -13, 11,  -13, 10,	-13, 9,	-13, 8,	-13, 7,	-13, 6,	-13, 5,	-13,4,	-13,3,	-13,2,	-13,1,	-13,0,	-13,-1,	-13,-2,	-13,-3,	-13,-4,	-13,-5,	-13,-6,	-13,-7,	-13,-8,	-13,-9,	-13,-10,	-13,-11,  -13, -12,
	13, 12,  13, 11,	13, 10,	13, 9,	13, 8,	13, 7,	13, 6,	13, 5,	13,4,	13,3,	13,2,	13,1,	13,0,	13,-1,	13,-2,	13,-3,	13,-4,	13,-5,	13,-6,	13,-7,	13,-8,	13,-9,	13,-10,	13,-11,  13, -12,

	-14, 14,  -13,  14,  -12, 14,	-11, 14,	-10, 14,	-9, 14,	-8, 14,	-7, 14,	-6 , 14,	-5 , 14,	-4 , 14,	-3 , 14,	-2 , 14,	-1 , 14,	0 , 14,	1 , 14,	2 , 14,	3 , 14,	4 , 14,	5 , 14,	6 , 14,	7 , 14,	8 , 14,	9 , 14,	10 , 14,	11 , 14,	12, 14,  13, 14,  14 , 14,
	-14, -14,	-13, -14,  -12, -14,  -11 , -14,	-10 , -14,	-9 , -14,	-8 , -14,	-7 , -14,	-6 , -14,	-5 , -14,	-4 , -14,	-3 , -14,	-2 , -14,	-1 , -14,	0 , -14,	1 , -14,	2 , -14,	3 , -14,	4 , -14,	5 , -14,	6 , -14,	7 , -14,	8 , -14,	9 , -14,	10 , -14,	11 , -14,  12, -14,	13, -14,  14 , -14,
	-14, 13,  -14, 12,  -14, 11,  -14, 10,	-14, 9,	-14, 8,	-14, 7,	-14, 6,	-14, 5,	-14,4,	-14,3,	-14,2,	-14,1,	-14,0,	-14,-1,	-14,-2,	-14,-3,	-14,-4,	-14,-5,	-14,-6,	-14,-7,	-14,-8,	-14,-9,	-14,-10,	-14,-11,  -14, -12, -14, -13,
	14, 13,  14, 12,  14, 11,	14, 10,	14, 9,	14, 8,	14, 7,	14, 6,	14, 5,	14,4,	14,3,	14,2,	14,1,	14,0,	14,-1,	14,-2,	14,-3,	14,-4,	14,-5,	14,-6,	14,-7,	14,-8,	14,-9,	14,-10,	14,-11,  14, -12, 14, -13,

	-15, 15,  -14, 15,  -13,  15,  -12, 15,	-11, 15,	-10, 15,	-9, 15,	-8, 15,	-7, 15,	-6 , 15,	-5 , 15,	-4 , 15,	-3 , 15,	-2 , 15,	-1 , 15,	0 , 15,	1 , 15,	2 , 15,	3 , 15,	4 , 15,	5 , 15,	6 , 15,	7 , 15,	8 , 15,	9 , 15,	10 , 15,	11 , 15,	12, 15,  13, 15,  14, 15,  15 , 15,
	-15, -15,  -14, -15,  -13, -15,  -12, -15,  -11 , -15,	-10 , -15,	-9 , -15,	-8 , -15,	-7 , -15,	-6 , -15,	-5 , -15,	-4 , -15,	-3 , -15,	-2 , -15,	-1 , -15,	0 , -15,	1 , -15,	2 , -15,	3 , -15,	4 , -15,	5 , -15,	6 , -15,	7 , -15,	8 , -15,	9 , -15,	10 , -15,	11 , -15,  12, -15,	13, -15,  14, -15,  15 , -15,
	-15, 14,  -15, 13,  -15, 12,  -15, 11,  -15, 10,	-15, 9,	-15, 8,	-15, 7,	-15, 6,	-15, 5,	-15,4,	-15,3,	-15,2,	-15,1,	-15,0,	-15,-1,	-15,-2,	-15,-3,	-15,-4,	-15,-5,	-15,-6,	-15,-7,	-15,-8,	-15,-9,	-15,-10,	-15,-11,  -15, -12, -15, -13,  -15, -14,
	15, 14,  15, 13,  15, 12,  15, 11,	15, 10,	15, 9,	15, 8,	15, 7,	15, 6,	15, 5,	15,4,	15,3,	15,2,	15,1,	15,0,	15,-1,	15,-2,	15,-3,	15,-4,	15,-5,	15,-6,	15,-7,	15,-8,	15,-9,	15,-10,	15,-11,  15, -12, 15, -13,  15, -14,

	-16, 16,  -15, 16,  -14, 16,  -13,  16,  -12, 16,	-11, 16,	-10, 16,	-9, 16,	-8, 16,	-7, 16,	-6 , 16,	-5 , 16,	-4 , 16,	-3 , 16,	-2 , 16,	-1 , 16,	0 , 16,	1 , 16,	2 , 16,	3 , 16,	4 , 16,	5 , 16,	6 , 16,	7 , 16,	8 , 16,	9 , 16,	10 , 16,	11 , 16,	12, 16,  13, 16,  14, 16,  15, 16,  16 , 16,
	-16, -16,  -15, -16,  -14, -16,  -13, -16,  -12, -16,  -11 , -16,	-10 , -16,	-9 , -16,	-8 , -16,	-7 , -16,	-6 , -16,	-5 , -16,	-4 , -16,	-3 , -16,	-2 , -16,	-1 , -16,	0 , -16,	1 , -16,	2 , -16,	3 , -16,	4 , -16,	5 , -16,	6 , -16,	7 , -16,	8 , -16,	9 , -16,	10 , -16,	11 , -16,  12, -16,	13, -16,  14, -16,  15, -16,  16 , -16,
	-16, 15,  -16, 14,  -16, 13,  -16, 12,  -16, 11,  -16, 10,	-16, 9,	-16, 8,	-16, 7,	-16, 6,	-16, 5,	-16,4,	-16,3,	-16,2,	-16,1,	-16,0,	-16,-1,	-16,-2,	-16,-3,	-16,-4,	-16,-5,	-16,-6,	-16,-7,	-16,-8,	-16,-9,	-16,-10,	-16,-11,  -16, -12, -16, -13,  -16, -14,  -16, -15,
	16, 15,  16, 14,  16, 13,  16, 12,  16, 11,	16, 10,	16, 9,	16, 8,	16, 7,	16, 6,	16, 5,	16,4,	16,3,	16,2,	16,1,	16,0,	16,-1,	16,-2,	16,-3,	16,-4,	16,-5,	16,-6,	16,-7,	16,-8,	16,-9,	16,-10,	16,-11,  16, -12, 16, -13,  16, -14,  16, -15,

	-17, 17,  -16, 17,  -15, 17,  -14, 17,  -13,  17,  -12, 17,	-11, 17,	-10, 17,	-9, 17,	-8, 17,	-7, 17,	-6 , 17,	-5 , 17,	-4 , 17,	-3 , 17,	-2 , 17,	-1 , 17,	0 , 17,	1 , 17,	2 , 17,	3 , 17,	4 , 17,	5 , 17,	6 , 17,	7 , 17,	8 , 17,	9 , 17,	10 , 17,	11 , 17,	12, 17,  13, 17,  14, 17,  15, 17,  16, 17,  17 , 17,
	-17, -17,  -16, -17,  -15, -17,  -14, -17,  -13, -17,  -12, -17,  -11 , -17,	-10 , -17,	-9 , -17,	-8 , -17,	-7 , -17,	-6 , -17,	-5 , -17,	-4 , -17,	-3 , -17,	-2 , -17,	-1 , -17,	0 , -17,	1 , -17,	2 , -17,	3 , -17,	4 , -17,	5 , -17,	6 , -17,	7 , -17,	8 , -17,	9 , -17,	10 , -17,	11 , -17,  12, -17,	13, -17,  14, -17,  15, -17,  16, -17,  17 , -17,
	-17, 16,  -17, 15,  -17, 14,  -17, 13,  -17, 12,  -17, 11,  -17, 10,	-17, 9,	-17, 8,	-17, 7,	-17, 6,	-17, 5,	-17,4,	-17,3,	-17,2,	-17,1,	-17,0,	-17,-1,	-17,-2,	-17,-3,	-17,-4,	-17,-5,	-17,-6,	-17,-7,	-17,-8,	-17,-9,	-17,-10,	-17,-11,  -17, -12, -17, -13,  -17, -14,  -17, -15,  -17, -16,
	17, 16,  17, 15,  17, 14,  17, 13,  17, 12,  17, 11,	17, 10,	17, 9,	17, 8,	17, 7,	17, 6,	17, 5,	17,4,	17,3,	17,2,	17,1,	17,0,	17,-1,	17,-2,	17,-3,	17,-4,	17,-5,	17,-6,	17,-7,	17,-8,	17,-9,	17,-10,	17,-11,  17, -12, 17, -13,  17, -14,  17, -15,  17, -16,

	-18, 18,  -17, 18,  -16, 18,  -15, 18,  -14, 18,  -13,  18,  -12, 18,	-11, 18,	-10, 18,	-9, 18,	-8, 18,	-7, 18,	-6 , 18,	-5 , 18,	-4 , 18,	-3 , 18,	-2 , 18,	-1 , 18,	0 , 18,	1 , 18,	2 , 18,	3 , 18,	4 , 18,	5 , 18,	6 , 18,	7 , 18,	8 , 18,	9 , 18,	10 , 18,	11 , 18,	12, 18,  13, 18,  14, 18,  15, 18,  16, 18,  17, 18,  18 , 18,
	-18, -18,  -17, -18,  -16, -18,  -15, -18,  -14, -18,  -13, -18,  -12, -18,  -11 , -18,	-10 , -18,	-9 , -18,	-8 , -18,	-7 , -18,	-6 , -18,	-5 , -18,	-4 , -18,	-3 , -18,	-2 , -18,	-1 , -18,	0 , -18,	1 , -18,	2 , -18,	3 , -18,	4 , -18,	5 , -18,	6 , -18,	7 , -18,	8 , -18,	9 , -18,	10 , -18,	11 , -18,  12, -18,	13, -18,  14, -18,  15, -18,  16, -18,  17, -18,  18 , -18,
	-18, 17,  -18, 16,  -18, 15,  -18, 14,  -18, 13,  -18, 12,  -18, 11,  -18, 10,	-18, 9,	-18, 8,	-18, 7,	-18, 6,	-18, 5,	-18,4,	-18,3,	-18,2,	-18,1,	-18,0,	-18,-1,	-18,-2,	-18,-3,	-18,-4,	-18,-5,	-18,-6,	-18,-7,	-18,-8,	-18,-9,	-18,-10,	-18,-11,  -18, -12, -18, -13,  -18, -14,  -18, -15,  -18, -16,  -18, -17,
	18, 17,  18, 16,  18, 15,  18, 14,  18, 13,  18, 12,  18, 11,	18, 10,	18, 9,	18, 8,	18, 7,	18, 6,	18, 5,	18,4,	18,3,	18,2,	18,1,	18,0,	18,-1,	18,-2,	18,-3,	18,-4,	18,-5,	18,-6,	18,-7,	18,-8,	18,-9,	18,-10,	18,-11,  18, -12, 18, -13,  18, -14,  18, -15,  18, -16,  18, -17,

	-19, 19,  -18, 19,  -17, 19,  -16, 19,  -15, 19,  -14, 19,  -13,  19,  -12, 19,	-11, 19,	-10, 19,	-9, 19,	-8, 19,	-7, 19,	-6 , 19,	-5 , 19,	-4 , 19,	-3 , 19,	-2 , 19,	-1 , 19,	0 , 19,	1 , 19,	2 , 19,	3 , 19,	4 , 19,	5 , 19,	6 , 19,	7 , 19,	8 , 19,	9 , 19,	10 , 19,	11 , 19,	12, 19,  13, 19,  14, 19,  15, 19,  16, 19,  17, 19,  18, 19,  19 , 19,
	-19, -19,  -18, -19,  -17, -19,  -16, -19,  -15, -19,  -14, -19,  -13, -19,  -12, -19,  -11 , -19,	-10 , -19,	-9 , -19,	-8 , -19,	-7 , -19,	-6 , -19,	-5 , -19,	-4 , -19,	-3 , -19,	-2 , -19,	-1 , -19,	0 , -19,	1 , -19,	2 , -19,	3 , -19,	4 , -19,	5 , -19,	6 , -19,	7 , -19,	8 , -19,	9 , -19,	10 , -19,	11 , -19,  12, -19,	13, -19,  14, -19,  15, -19,  16, -19,  17, -19,  18, -19,  19 , -19,
	-19, 18,  -19, 17,  -19, 16,  -19, 15,  -19, 14,  -19, 13,  -19, 12,  -19, 11,  -19, 10,	-19, 9,	-19, 8,	-19, 7,	-19, 6,	-19, 5,	-19,4,	-19,3,	-19,2,	-19,1,	-19,0,	-19,-1,	-19,-2,	-19,-3,	-19,-4,	-19,-5,	-19,-6,	-19,-7,	-19,-8,	-19,-9,	-19,-10,	-19,-11,  -19, -12, -19, -13,  -19, -14,  -19, -15,  -19, -16,  -19, -17, -19, -18,
	19, 18,  19, 17,  19, 16,  19, 15,  19, 14,  19, 13,  19, 12,  19, 11,	19, 10,	19, 9,	19, 8,	19, 7,	19, 6,	19, 5,	19,4,	19,3,	19,2,	19,1,	19,0,	19,-1,	19,-2,	19,-3,	19,-4,	19,-5,	19,-6,	19,-7,	19,-8,	19,-9,	19,-10,	19,-11,  19, -12, 19, -13,  19, -14,  19, -15,  19, -16,  19, -17,  19, -18,

	-20, 20,  -19, 20,  -18, 20,  -17, 20,  -16, 20,  -15, 20,  -14, 20,  -13,  20,  -12, 20,	-11, 20,	-10, 20,	-9, 20,	-8, 20,	-7, 20,	-6 , 20,	-5 , 20,	-4 , 20,	-3 , 20,	-2 , 20,	-1 , 20,	0 , 20,	1 , 20,	2 , 20,	3 , 20,	4 , 20,	5 , 20,	6 , 20,	7 , 20,	8 , 20,	9 , 20,	10 , 20,	11 , 20,	12, 20,  13, 20,  14, 20,  15, 20,  16, 20,  17, 20,  18, 20,  19, 20,  20 , 20,
	-20, -20,  -19, -20,  -18, -20,  -17, -20,  -16, -20,  -15, -20,  -14, -20,  -13, -20,  -12, -20,  -11 , -20,	-10 , -20,	-9 , -20,	-8 , -20,	-7 , -20,	-6 , -20,	-5 , -20,	-4 , -20,	-3 , -20,	-2 , -20,	-1 , -20,	0 , -20,	1 , -20,	2 , -20,	3 , -20,	4 , -20,	5 , -20,	6 , -20,	7 , -20,	8 , -20,	9 , -20,	10 , -20,	11 , -20,  12, -20,	13, -20,  14, -20,  15, -20,  16, -20,  17, -20,  18, -20,  19, -20,  20 , -20,
	-20, 19,  -20, 18,  -20, 17,  -20, 16,  -20, 15,  -20, 14,  -20, 13,  -20, 12,  -20, 11,  -20, 10,	-20, 9,	-20, 8,	-20, 7,	-20, 6,	-20, 5,	-20,4,	-20,3,	-20,2,	-20,1,	-20,0,	-20,-1,	-20,-2,	-20,-3,	-20,-4,	-20,-5,	-20,-6,	-20,-7,	-20,-8,	-20,-9,	-20,-10,	-20,-11,  -20, -12, -20, -13,  -20, -14,  -20, -15,  -20, -16,  -20, -17, -20, -18, -20, -19,
	20, 19,  20, 18,  20, 17,  20, 16,  20, 15,  20, 14,  20, 13,  20, 12,  20, 11,	20, 10,	20, 9,	20, 8,	20, 7,	20, 6,	20, 5,	20,4,	20,3,	20,2,	20,1,	20,0,	20,-1,	20,-2,	20,-3,	20,-4,	20,-5,	20,-6,	20,-7,	20,-8,	20,-9,	20,-10,	20,-11,  20, -12, 20, -13,  20, -14,  20, -15,  20, -16,  20, -17,  20, -18,  20, -19,

} ;

short g_pDetectEnemyRadius[eRds_MaxDetectEnemy+1] = { 0, 8, 24, 48, 80, 120, 168, 224, 288, 360, 440, 528, 624, 728, 840, 960, 1088, 1224, 1368, 1520, ePos_MaxPosCount } ;


short g_krgRoamPath[eRoam_MaxPathCount][8] =
{
	  0, -2,	2,  0,		 0,  2,		-2,  0,
	  0,  2,	1, -2,		-1, -2,		-1,  2,
	 -2,  0,	1, -2,		 1,  0,		 1,  2,
	 -1,  0,	1, -2,		 1,  2,		-2,  1,
} ;





int Percent( double a_dValue, double a_dPercent )
{
	if( 100 == a_dPercent ) return (int)a_dValue ;
	if( 0 == a_dValue ) return 0 ;
	if( 0 == a_dPercent ) return 0 ;
	a_dPercent /= 100 ;
	a_dValue *= a_dPercent ;
	if( 0 < a_dValue ) a_dValue += 0.5 ;
	else if( 0 > a_dValue ) a_dValue -= 0.5 ;

	return (int)a_dValue ;
}


BOOL	BASE_CanTrade(STRUCT_ITEM * Inven,int nCount,STRUCT_ITEM *MyTrade,STRUCT_ITEM * OpponentTrade)
{
	int empty		= 0;
	int NumOpponent = 0;
	int NumMy		= 0;
	int i=0;
	for	(i=0;i<MAX_TRADE;i++)
	{	if	(OpponentTrade[i].snIndex)	NumOpponent++;
		if	(MyTrade[i].snIndex)		NumMy++;
	}
	int maxinven = nCount;// according to backpack size
	for	(i=0;i<maxinven; i++)
	{	if	(Inven[i].snIndex==0) empty++;
	}
	int result = empty+NumMy-NumOpponent;
	if	(result<0) return FALSE;

	return TRUE;
}
#ifdef __ZONE_SERVER__
#define MAX_CHECKLOGITEM 128
const short g_snCheckLogItemIndex[MAX_CHECKLOGITEM] = { 
	3026, 3027, 3077, 3330, 3331, 3332, 3333, 3334, 3335, 3361, 
	3362, 3363, 3364, 3365, 3372, 3379, 3380, 3381, 3192, 3193,
	3194, 3195, 3196, 3197, 3198, 3199, 3200, 3201, 3203, 3204,
	3205, 3206, 3207, 3208, 3209, 3210, 3211, 3212, 3213, 3214,
	3215, 3216, 3217, 3218, 3219, 3220, 3221, 3222, 3223, 3224, 
	2722, 3402, 3383, 3359, 3360, 2719, 2720, 2729, 2730, 2731, 
	2733, 2734, 2735,
	0,
};

BOOL BASE_CheckItemLog(STRUCT_ITEM *pItem)
{
	return ( 0 != (pItemData[pItem->snIndex].sType & 0x0001) );
}
#endif
void BASE_GetItemCode(STRUCT_ITEM * item,char * str) // 16 byte, // word:sindex 
{    
	sprintf(str,"%04X %04X %04X %02X %02X%02X%02X%02X%02X %02X",
			item->snIndex,
			item->wSerial,
			item->snDurability, 
			item->byCount,
			item->bySubRefine[0],
			item->bySubRefine[1],
			item->bySubRefine[2],
			item->bySubRefine[3],
			item->bySubRefine[4],
			item->byRefineLevel );
	return;
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                         BASE_GetMobCheckSum 
// Item 장착 해지 등에, CheckSum을 비교해 Client 해킹등을 체크하고, 아이템 창착, 획득등의 변경을 컨펌.
int BASE_GetMobCheckSum(STRUCT_MOB * mob)
{   int sum=0;
 //   int i;
	//memset((void*)&mob->BaseScore,0,sizeof(mob->BaseScore));
 //   for (i=0;i<MAX_EQUIP;i++)    sum=sum+mob->Equip[i].nIndex * i;
 //   for (i=0;i<MAX_Inven;i++)    sum=sum+mob->Inven[i].nIndex * i;
	return sum;
}




////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//          Check 계통의 펑션들 
//     BASE_CheckValidString     -  계정에 사용가능한 문제를 체크
//     BASE_CheckHangul          -  
////////////////////////////////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////////////////////////////
//           BASE_CheckValidString
// 특수문자 제한
#define ISALPHA(x)		( ((x)>='a'&&(x)<='z') || ((x)>='A'&&(x)<='Z')  )
#define ISDIGIT(x)		  ((x)>='0'&&(x)<='9')

bool BASE_CheckValidString(char * name)
{
	 int l = (int)strlen(name);
	 if  (l<4 || l>=SZNAME_LENGTH)  return FALSE;        // 4자 미만 또는 26자 초과시 X

	 for ( int j=0; j<l; j++ )
	 {	 char x = name[j];
	     //  2바이트면 통과 (한자 한글 특문)
	     if  (x<0) {j++;continue;}
         //  1바이트는 숫자,알파벳,"-" 만 통과
	 	 if  (ISALPHA(x) || ISDIGIT(x) || x=='-' || x=='_')  continue;
         // 아니면 실패
         return FALSE;
	 }
	 return true;
}

bool BASE_CheckHangul(unsigned short word)
{   
	 unsigned char x = (unsigned char) word;
	 unsigned char y = (unsigned char) (word>>8);
	 if (x>=0xb0 && x<=0xc9 && y>=0xa1&&y<=0xff )	return true;
	 else return false;
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////




 

////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//          Init 계통의 펑션들 
//     BASE_InitializeBaseDef     - 총괄 Server,Client에 따라서 다르게 실행
//     BASE_InitModuleDir         - 디렉토리 초기화  
//
////////////////////////////////////////////////////////////////////////////////////////////////////////////////
int  BASE_InitializeBaseDef(E_COUNTRY_ID contry)
{
     //g_pItemList = NULL;
	 //g_pItemList = (STRUCT_ITEMLIST*) malloc(sizeof(STRUCT_ITEMLIST)*MAX_ITEMLIST);

	//memset(ChargedGuildList,0,sizeof(ChargedGuildList));

	BASE_InitializeServerList();
	int ret		= 1;
	//int tret	= 0;			

	//#ifdef WYD_CLIENT
	//    #ifdef _DEBUG 
	//	   BASE_InitializeSkill();	        BASE_WriteSkillBin();
	// 	   BASE_InitializeEffectName(); 
 //          BASE_InitializeItemList();	
	//	   for (int i=0;i<MAX_ITEMLIST;i++)BASE_UnderBarToSpace(g_pItemList[i].Name); 		   
	//	   BASE_InitializeInitItem();   // ItemList후에.
	//	   BASE_WriteInitItem();		   
	//	#else
	//		tret = BASE_ReadSkillBin();			ret = ret&tret;
 //           tret = BASE_ReadItemList();		    ret = ret&tret;
	//		tret = BASE_ReadInitItem();			ret = ret&tret;
	//	#endif
	//		memset(g_pClientGuildName,0,sizeof(g_pClientGuildName));
 //	#else
	//	    BASE_InitializeSkill();
	//	    BASE_InitializeEffectName();
	//		BASE_InitializeItemList();
	//	    BASE_InitializeInitItem();   // ItemList후에.
	//		BASE_InitializeGuildName();
	//#endif

	//#ifdef	_CHINESESIMPLE
	//	g_pItemList[412].nPrice=4000000;
	//	g_pItemList[413].nPrice=8000000;
	//	g_pItemList[419].nPrice=400000;
	//	g_pItemList[420].nPrice=800000;

	//#endif
	//#ifdef	_CHINESETRADITION
	//	g_pItemList[412].nPrice=8000000;
	//	g_pItemList[413].nPrice=16000000;
	//	g_pItemList[419].nPrice=800000;
	//	g_pItemList[420].nPrice=1600000;
	//#endif

     BASE_InitializeAttribute(contry);

	 return ret;
}


////////////////////ss//////////////////////////////////////////////////////////////////////////////////////////
//        BASE_InitModuleDir(void)
// Working Directory를 exe파일이 있는 디렉토리로 세팅.
// 어플리케이션 선두에 반드시 실행.
void BASE_InitModuleDir(void)
{	char String[256]; GetModuleFileName(NULL,String,256);
	int len=(int)strlen(String);
	for (int i=len-1;i>0;i--)
	{	if (String[i]=='\\'){String[i]=0;break;}
	}
	SetCurrentDirectory(String);	
}
int BASE_GetSum(char * p ,int size)
{
	int sum = 0;
    for (int i=0;i<size;i++)
	{    int mod = i%7;
	     if (mod==0) sum=sum+p[i]/2;
	     if (mod==1) sum=sum+(p[i]^0xFF);
		 if (mod==2) sum=sum+p[i]*3;
	 	 if (mod==3) sum=sum+p[i]*2;
		 if (mod==4) sum=sum-(p[i]/7);
		 if (mod==5) sum=sum-p[i];
		 else sum=sum+(p[i]/3);
	}
	return sum;
}
int BASE_GetSum2(char * p ,int size)
{
	int sum = 0;
    for (int i=0;i<size;i++)
	{    int mod = i%9;
	     if (mod==0) sum=sum+p[i]*2;
	     if (mod==1) sum=sum+(p[i]^0xFF);
		 if (mod==2) sum=sum+p[i]/3;
	 	 if (mod==3) sum=sum+p[i]*2;
		 if (mod==4) sum=sum-(p[i]^0x5A);
		 if (mod==5) sum=sum-p[i];
		 else sum=sum+(p[i]/5);
	}
	return sum;
}

// ItemList 를 초기화하기 위한 함수들. (Client의 Binary파일 생성을 위해서 WYD_SERVER,_DEBUG가 사용됨)
void BASE_WriteSkillBin()
{
	//STRUCT_SPELL g_pSpell[MAX_CLASS][MAX_SKILL];  // InitializeSkillData
/*	int size = sizeof(STRUCT_SPELL) * MAX_CLASS*MAX_SKILL;
	char * temp = (char *)g_pSpell;
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
	FILE* fp = fopen("SkillData.bin", "wb");
	if  (fp!=NULL)
	{	fwrite(g_pSpell, sizeof(STRUCT_SPELL), MAX_CLASS*MAX_SKILL , fp);
		int sum = BASE_GetSum2((char*)g_pSpell,size);
		int nRand = rand();
		fwrite(&nRand, sizeof(nRand), 1 , fp);
		fclose(fp);

		FILE* fpCSum = fopen("..\\SkillCSum.h", "wt");
		if(fpCSum!=NULL){
			fprintf(fpCSum, "#define SKILL_CHECKSUM %d", sum);
			fclose(fp);
		}
		
	}
	for (i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
*/
}

void BASE_WriteItemList(int nItemList)
{
/*
	int size = sizeof(STRUCT_ITEMLIST)*MAX_ITEMLIST;
	char *temp = (char*)g_pItemList;
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
	FILE* fp = NULL;
	if(nItemList==0){
		fp = fopen(".\\ItemList.bin", "wb");
		if(fp==NULL) {MessageBox(NULL,"ItemList.bin을 생성할수 없습니다. ","ERROR",NULL);return;}
		//fwrite(g_pItemList, sizeof(STRUCT_ITEMLIST)*FIXED_ITEMLIST, 1, fp);
	}
	int sum = BASE_GetSum2((char*)g_pItemList,size);
	int nRand = rand();
	if(nItemList==0){
		fwrite(&nRand, sizeof(nRand), 1 , fp);
		fclose(fp);
	}
	FILE* fpCSum = NULL;
	if(nItemList==0)	fpCSum = fopen("..\\ItemCSum.h", "wt");
	else				fpCSum = fopen("..\\ItemCSum.h", "a+");
	if(fpCSum!=NULL){
		if(nItemList==0)	fprintf(fpCSum, "#define ITEM_CHECKSUM %d\n", sum);
		else				fprintf(fpCSum, "#define ITEM_CHECKSUM2 %d\n", sum);
		fclose(fpCSum);
	}

     for ( i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
	 */
}

int BASE_ReadSkillBin()
{
/*
	int size = sizeof(STRUCT_SPELL) * MAX_CLASS*MAX_SKILL;
	char * temp = (char *)g_pSpell;
	int  tsum = 0;
	FILE* fp = fopen("SkillData.bin", "rb");
	if(fp!=NULL){
		fread(g_pSpell, size , 1 , fp);
		fread(&tsum, sizeof(tsum), 1 , fp);
		fclose(fp);
	}
	else{
		MessageBox(NULL,"Can't read SkillData.bin","ERROR",NULL);
		return FALSE;
	}
	int sum=BASE_GetSum2((char*)g_pSpell,size);
	#ifndef _DEBUG
		if (SKILL_CHECKSUM!=sum) return FALSE;
	#endif
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}*/
	return TRUE;
}

int  BASE_ReadItemList(void)
{
/*	int size = sizeof(STRUCT_ITEMLIST)*MAX_ITEMLIST;
	char *temp = (char*)g_pItemList;
	int tsum = 0;
	FILE* fp;
	fp = fopen(".\\ItemList.bin", "rb");
	if(fp==NULL) {MessageBox(NULL,"Can't read ItemList.bin","ERROR",NULL);return FALSE;}
	fread(g_pItemList, sizeof(STRUCT_ITEMLIST)*FIXED_ITEMLIST, 1, fp);
	fread(&tsum, sizeof(tsum), 1 , fp);
	fclose(fp);
	int sum=BASE_GetSum2((char*)g_pItemList,size);
	#ifndef _DEBUG
		if (ITEM_CHECKSUM!=sum) return FALSE;
	#endif
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}

  
	int Handle = open(".\\ExtraItem.bin", _O_RDONLY|_O_BINARY,0);
	if(Handle==-1) ;//{MessageBox(NULL,"Can't read ExtraItem.bin","ERROR",NULL);return FALSE;}
	else
	{	
		while(1)
		{	char buff[256];
			STRUCT_ITEMLIST * item;
			int sz = read(Handle,buff,sizeof(STRUCT_ITEMLIST)+2);
			if (sz<sizeof(STRUCT_ITEMLIST)+2) break;
			short idx = *((short*) buff);
			if	(idx<=0||idx>=MAX_ITEMLIST) continue;
			item = (STRUCT_ITEMLIST *)(buff+2);
			g_pItemList[idx] = *item;
		}
		close(Handle);

		#ifndef _DEBUG
			for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
			int sum=BASE_GetSum2((char*)g_pItemList,size);
			if (ITEM_CHECKSUM2!=sum) return FALSE;
			for ( i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
		#endif
	}
	*/
	return TRUE;
}

void BASE_SpaceToUnderBar(char* szStr)
{    for(unsigned int i=0;i<strlen(szStr);i++)
     {		if(*(szStr + i)==' '){*(szStr + i) = '_';}
	 }
}
void BASE_UnderBarToSpace(char* szStr)
{ 	
	int nStrLen = (int)strlen(szStr);
	unsigned char* pStr = (unsigned char*)szStr;
	unsigned char* pNext = _mbschr(pStr, '_');
	while(pNext){
		*pNext = ' ';
		pNext = _mbschr(pNext, '_');
		nStrLen--;
		if(nStrLen<0) break;
	}
}

// 가:0  까:171 나:291 다:432 따: 라:646  마:773 바:902  빠:1031 사:1104 싸:1237 아:1353 자:1561 짜:1696 차:1770 카:1890 타:1997 파:2103  하:2208 끝:2350
char KorFirst[40]="ㄱㄲㄴㄷㄸㄹㅁㅂㅃㅅㅆㅇㅈㅉㅊㅋㅌㅍㅎ";
int  KorIndex[19]={171,291,432,560,646,773,902,1031,1104,1237,1353,1561,1696,1770,1890,1997,2103,2208,2350};
void BASE_GetFirstKey(char * source,char * dest)
{
	 if  ((source[0]>='A'&& source[0]<='Z')||(source[0]>='a'&& source[0]<='z'))
	 {   dest[0]=source[0];
	     dest[1]=0;
	 	 return;
	 }   else
	 if  (source[0]<0)
	 {   unsigned char * unsource = (unsigned char*) source;
		 int Point = (unsource[0]-0xb0)*94  + unsource[1]-0xa1; 
         if (Point<0||Point>=2350)
		 {  strcpy(dest,"etc");
		    return;
		 }

		 for (int a=0;a<18;a++)
		 {   if (Point<KorIndex[a]) break;
		 }

		 if  (a>=0 && a<=17)
		 {   dest[0]=KorFirst[a*2];
		     dest[1]=KorFirst[a*2+1];
		     dest[2]=0;
		 }   else
		 {   strcpy(dest,"etc");
		     return;
		 }

	 }  else
	 {  strcpy(dest,"etc");
	 }

     
     return;
}

int  BASE_GetIndex(STRUCT_ITEM * item)
{
 //   int hword=0;
	//int lword=0;
	//if	(item->nIndex>=2330 && item->nIndex<2390) return 0;

 //   if (item->stEffect[0].cEffect==EF_HWORDINDEX || item->stEffect[1].cEffect==EF_HWORDINDEX || item->stEffect[2].cEffect==EF_HWORDINDEX)
	//{  if (item->stEffect[0].cEffect==EF_HWORDINDEX) hword = (unsigned char)item->stEffect[0].cValue; else
 //      if (item->stEffect[1].cEffect==EF_HWORDINDEX) hword = (unsigned char)item->stEffect[1].cValue; else
	//   hword = (unsigned char)item->stEffect[2].cValue;
	//}
 //   if (item->stEffect[0].cEffect==EF_LWORDINDEX || item->stEffect[1].cEffect==EF_LWORDINDEX || item->stEffect[2].cEffect==EF_LWORDINDEX)
	//{  if (item->stEffect[0].cEffect==EF_LWORDINDEX) lword = (unsigned char)item->stEffect[0].cValue; else
 //      if (item->stEffect[1].cEffect==EF_LWORDINDEX) lword = (unsigned char)item->stEffect[1].cValue; else
	//   lword = (unsigned char)item->stEffect[2].cValue;
	//}
 //   int value = hword*256+lword;
	//return value;
	return 0;
}

STRUCT_ITEM * GetItemPointer(STRUCT_MOB * mob, STRUCT_ITEM * cargo,int type,int pos)
{
	STRUCT_ITEM * sour = NULL;
    if  (type==0)
    {   if (pos<0||pos>=MAX_EQUIP) {return 0;}
	    sour = &mob->Equip[pos];
    }   else
    if  (type==1)
    {   if (pos<0||pos>=MAX_INVEN){return 0;}
        sour = &mob->Inven[pos];
    }   else
    if  (type==2)
    {   if (pos<0||pos>=MAX_CARGO) { return 0;}
        sour = &cargo[pos];
   }  else
   {   return 0; 
   }			   
//   if  (sour->snIndex<=0||sour->snIndex>MAX_ITEMLIST) return 0; 
   return sour;

}

void BASE_GetKorFirst(int temp,int *a)
{ 
     int word1;
     int temp1;
     word1=(temp>>10)&31;
     word1=word1-1;
     temp1=word1;
     *a=temp1;
}

void BASE_InitializeMessage(char * file)
{
	 memset(g_pMessageStringTable,MAX_STRING,128);
     FILE * fp  =  fopen(file,"rt");
     if (fp==NULL) return;
	 char str[512];
	 char part1[256];
	 char *cont;
	 while(1)
	 {
		int  Index = -1;
		char * ret = fgets((char*)str,1024,fp);
		if (ret==NULL) break;
        sscanf(str,"%d %s",&Index,part1);
		str[510]=0; str[511]=0; 
		if (Index<=0||Index>=MAX_STRING) continue;
		int TabPos=0;
		for (int i=0;i<256;i++)
		{   if (str[i]=='\t') {TabPos=i;break;} }
		if (TabPos==0)
		{  MessageBox(NULL,str,"Can't parse String",MB_OK);
		   continue;
		}
        cont = (char*) (str+TabPos+1);
		for (i=0;i<128;i++)
		{   if (cont[i]=='\t'||cont[i]==10||cont[i]==0) {cont[i]=0;break;} }

        int len = (int)strlen(cont);
		if (len<=0||len>=128)//인도네시아 번전은 languig.txt가 너무 길어 일단 블록한다. 추후 문자길이 조정후 다시 어야한다.
		{  //	MessageBox(NULL,str,"Empty or Long String",MB_OK);
		   continue;
		}

		strcpy((char*)g_pMessageStringTable[Index],cont);
	 }
     fclose(fp);
}

void BASE_InitializeszName(char * file,int offset)
{
	/*
	if	(offset==0) memset(g_pEnglish,0,sizeof(g_pEnglish));
    FILE * fp  =  fopen(file,"rt");
    if (fp==NULL) return;
	char str[512];
	char part1[256];
	char *cont;
	int Index = 0;
	if	(offset==0)
	{
		while(1)
		{
			char * ret = fgets((char*)str,1024,fp);
			if (ret==NULL) break;
	        sscanf(str,"%s",part1);
			str[510]=0; str[511]=0; 
			int TabPos=0;
			for (int i=0;i<256;i++)	{   if (str[i]=='\t') {TabPos=i;break;} }
			if (TabPos==0)	{  MessageBox(NULL,str,"Can't parse String",MB_OK);	   continue;	}
			cont = (char*) (str+TabPos+1);
			for (i=0;i<128;i++)	{if (cont[i]=='\t'||cont[i]==10||cont[i]==0) {cont[i]=0;break;} }
			int len = 0;
			len = strlen(part1);if (len<=0||len>=SZNAME_LENGTH){  MessageBox(NULL,str,"Empty or Long String-1st",MB_OK);   continue;}
			len = strlen(cont);	
			if (len<=0||len>=SZNAME_LENGTH)
			{  MessageBox(NULL,str,"Empty or Long String-2nd",MB_OK);   continue;}
			if (Index<0||Index>=MAX_ENGLISH){ MessageBox(NULL,str,"Too much items in szName.txt",MB_OK);  break;}
			strcpy((char*)g_pEnglish[Index][0],part1); // 한
			strcpy((char*)g_pEnglish[Index][1],cont);  // 영
			strcpy((char*)g_pEnglish[Index][2],part1);  // 영
			Index++;
		}
	}	else
	{
		while(1)
		{

			char * ret = fgets((char*)str,1024,fp);
			if (ret==NULL) break;
	        sscanf(str,"%s",part1);
			str[510]=0; str[511]=0; 
			int TabPos=0;
			for (int i=0;i<256;i++)	{   if (str[i]=='\t') {TabPos=i;break;} }
			if (TabPos==0)	{  MessageBox(NULL,str,"Can't parse String",MB_OK);	   continue;	}
			cont = (char*) (str+TabPos+1);
			for (i=0;i<128;i++)	{if (cont[i]=='\t'||cont[i]==10||cont[i]==0) {cont[i]=0;break;} }
			int len = 0;
			len = strlen(part1);if (len<=0||len>=SZNAME_LENGTH){  MessageBox(NULL,str,"Empty or Long String-1st",MB_OK);   continue;}
			len = strlen(cont);	if (len<=0||len>=SZNAME_LENGTH){  MessageBox(NULL,str,"Empty or Long String-2nd",MB_OK);   continue;}
			if (Index<0||Index>=MAX_ENGLISH){ MessageBox(NULL,str,"Too much items in szName.txt",MB_OK);  break;}

			for	(Index=0;Index<MAX_ENGLISH;Index++)
			{	if	(!strcmp(part1,g_pEnglish[Index][0]) || !strcmp(part1,g_pEnglish[Index][1]) )	break;
			}
			if	(Index==MAX_ENGLISH)
			{	MessageBox(NULL,str,"Can't Find match szName",MB_OK);  break;
			}	else 
			{	strcpy((char*)g_pEnglish[Index][2],cont);
			}
		}
	}

    fclose(fp);*/
}


void BASE_WriteMessageBin()
{
/*
	int size	= sizeof(char) * MAX_STRING*128;
	char * temp = (char *)g_pMessageStringTable;
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
	FILE* fp = fopen("UI/strdef.bin", "wb");
	if  (fp!=NULL)
	{	fwrite(g_pMessageStringTable, sizeof(char), MAX_STRING*128 , fp);
		int sum = BASE_GetSum((char*)g_pMessageStringTable,size);
		fwrite(&sum, sizeof(sum), 1 , fp);
		fclose(fp);
	}
	for (i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
	*/
}

BOOL BASE_ReadMessageBin()
{
	/*
	memset(g_pMessageStringTable,MAX_STRING,128);
	int size = sizeof(char) * MAX_STRING*128;
	char * temp = (char *)g_pMessageStringTable;
	int  tsum = 0;
	FILE* fp = fopen("UI/strdef.bin", "rb");
	if(fp!=NULL){
		fread(g_pMessageStringTable, size , 1 , fp);
		fread(&tsum, sizeof(tsum), 1 , fp);
		fclose(fp);
	}
	int sum=BASE_GetSum((char*)g_pMessageStringTable,size);
    if (sum!=tsum) return FALSE;
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0x5A;}
	*/
	return TRUE;	
}
void BASE_InitializeItemList(void)
{   
	char extraitem[128];
    int size = sizeof(STRUCT_ITEM)*MAX_ITEMLIST;
	memset(g_pItemList,0,size);
	int ret=TRUE;
	#ifdef	_CHINESESIMPLE
		ret = BASE_ReadItemListFile("itemlist_cs.csv",0); if (ret==FALSE) {MessageBox(NULL,"There is no file","itemlist.csv",NULL);return;}	
		strcpy(extraitem,"extraitem_cs.csv");		
	#elif	_CHINESETRADITION
		ret = BASE_ReadItemListFile("itemlist_ct.csv",0); if (ret==FALSE) {MessageBox(NULL,"There is no file","itemlist.csv",NULL);return;}	
		strcpy(extraitem,"extraitem_ct.csv");
	#else
		ret = BASE_ReadItemListFile("itemlist.csv",0); if (ret==FALSE) {MessageBox(NULL,"There is no file","itemlist.csv",NULL);return;}	
		strcpy(extraitem,"extraitem.csv");
	#endif


	
#ifdef WYD_CLIENT
	ret = BASE_ReadItemListFile(extraitem,1);
#else
	ret = BASE_ReadItemListFile(extraitem,0);
#endif

	// short + STRUCT_ITEMLIST

}

BOOL BASE_ReadItemListFile(char * filename,int Build)
{
	FILE * wfp;
	if	(Build)
	{	
		BASE_WriteItemList(0);
		wfp =  fopen("extraitem.bin","wb");
		if	(wfp==NULL) {MessageBox(NULL,"Can't write extraitem.bin","ERROR",MB_OK|MB_SYSTEMMODAL);return FALSE;}
	}
	
	char temp[256];
	sprintf(temp,"%s",filename);
	FILE * fp  =  fopen(temp,"rb");
    if	(fp==NULL) 
	{	sprintf(temp,"TMSRV/Run/%s",filename);
		fp =fopen(temp,"rb");
	}
	if (fp==NULL) return FALSE;
	/*
	while(1)
	{

		int  Index = -1;
      	char Name[256];  memset(Name,0,256);
	    char nE[MAX_STATICEFFECT][256]; memset(nE,0,sizeof(nE));
	    int  vE[MAX_STATICEFFECT];      memset(vE,0,sizeof(vE));
		int ve=sizeof(vE);
		int ne=sizeof(nE);

		char str[1024];
		char * ret = fgets((char*)str,1024,fp);
		if (ret==NULL) break;
		for (int i=0;i<1024;i++)
		{   if (str[i]==',') str[i]=' ';
		    if (str[i]==-0) break;
		}
        char temp1[256];temp1[0]=0;
		char temp2[256];temp2[0]=0;
		int unique=0;
		int nprice=0;
		int npos=0;
		int	Grade=0;
		int	Extra=0;
		sscanf(str,"%d %s %s %s %d %d %d %d %d %s %d %s %d %s %d %s %d %s %d %s %d %s %d %s %d %s %d %s %d %s %d %s %d",&Index,Name,temp1,temp2,&unique,&nprice,&npos,&Extra,&Grade,
			nE[0],&vE[0],nE[1],&vE[1],nE[2],&vE[2],nE[3],&vE[3],nE[4],&vE[4],nE[5],&vE[5],nE[6],&vE[6],nE[7],&vE[7],nE[8],&vE[8],nE[9],&vE[9],nE[10],&vE[10],nE[11],&vE[11]);
		if (Index==-1) continue;
		if (Index>=MAX_ITEMLIST)
		{	MessageBox(NULL,str,"check MAX_ITEMLIST",MB_OK);
			continue;
		} 

		int len = strlen(Name);
        if (len>=ITEMNAME_LENGTH-1)
		{  MessageBox(NULL,"too long Item Name",Name,MB_OK);
		   Name[ITEMNAME_LENGTH-1]=0;
		   Name[ITEMNAME_LENGTH-2]=0;
		}
 
		strcpy(g_pItemList[Index].Name,Name);
 
		
		int  Mesh=0;
	    int  Texture=0;
		int  ReqLvl=0;
        int  ReqStr=0;
		int  ReqInt=0;
		int  ReqDex=0;
		int  ReqCon=0;

		if (temp1[0]=='.') temp1[0]=32;
		if (temp2[0]=='.') temp2[0]=32;
		sscanf(temp1,"%d.%d",&Mesh,&Texture);
		sscanf(temp2,"%d.%d.%d.%d.%d",&ReqLvl,&ReqStr,&ReqInt,&ReqDex,&ReqCon);

	    g_pItemList[Index].nIndexMesh          = Mesh;
		g_pItemList[Index].nIndexTexture       = Texture;
		g_pItemList[Index].nReqLvl             = ReqLvl;
	    g_pItemList[Index].nReqStr             = ReqStr;
	    g_pItemList[Index].nReqInt             = ReqInt;
	    g_pItemList[Index].nReqDex             = ReqDex;
	    g_pItemList[Index].nReqCon             = ReqCon;
		g_pItemList[Index].nUnique             = unique;
		g_pItemList[Index].nPrice              = nprice;
		g_pItemList[Index].nPos                = npos;
		g_pItemList[Index].nGrade				= Grade;
		g_pItemList[Index].nExtra				= Extra;

   	    g_pItemList[Index].nIndexVisualEffect  = 0;  // 일단 쓰이지 않는다.
        for (int j=0;j<MAX_STATICEFFECT;j++)
		{   if (nE[j][0]==0) continue;
		    for (int v=0;v<MAX_EFFECTINDEX;v++)
			{	 if (!strcmp(EffectNameTable[v],nE[j])) break;  // MAX_DUR
			}
		    if (j==MAX_EFFECTINDEX)
			{  MessageBox(0,nE[j],"Unregisterd effect",0);
               continue;
			}   
			g_pItemList[Index].stEffect[j].sEffect = v;
			g_pItemList[Index].stEffect[j].sValue  = vE[j];
		}
		if	(Build)
		{	fwrite(&Index, 2,1, wfp);
			fwrite(&g_pItemList[Index], sizeof(STRUCT_ITEMLIST),1, wfp);
		}


	 } */
	 fclose(fp);
	 if (Build)
	 {	fclose(wfp);
		BASE_WriteItemList(1);
	 }
	 return TRUE;
}


//int  BASE_GetRoute(int x,int y,int *targetx,int *targety,char *Route,int distance, short** pHeight)
int  BASE_GetRoute(int x,int y,int *targetx,int *targety,char *Route,int distance, int a_iBlockedCell )
{
     int lastx = x;
     int lasty = y;
     int tx= *targetx;
	 int ty= *targety;
	 memset(Route,0,MAX_ROUTE);

	 for (int i=0;i<distance&&i<MAX_ROUTE-1;i++)
	 {
         if ((x-g_HeightPosX)<1||(y-g_HeightPosY)<1||(x-g_HeightPosX)>g_HeightWidth-2||(y-g_HeightPosY)>g_HeightHeight-2)
		 {  Route[i]=0;
			break;
		 }
		 int iUnreachableHeight = 60000 ; // 6만
         //int cul = pHeight[(y-g_HeightPosY  )*g_HeightWidth + x-g_HeightPosX   ];
		 int cul = g_krgCell[y-g_HeightPosY][x-g_HeightPosX].usHeight ;
		 if (cul>MH) int kk=0;
		 int nw  = g_krgCell[(y-g_HeightPosY-1)][x-g_HeightPosX-1 ].usHeight ;		 
         int n   = g_krgCell[(y-g_HeightPosY-1)][x-g_HeightPosX   ].usHeight ;
         int ne  = g_krgCell[(y-g_HeightPosY-1)][x-g_HeightPosX+1 ].usHeight ;
		 int w   = g_krgCell[(y-g_HeightPosY  )][x-g_HeightPosX-1 ].usHeight ;
         int e   = g_krgCell[(y-g_HeightPosY  )][x-g_HeightPosX+1 ].usHeight ;
		 int sw  = g_krgCell[(y-g_HeightPosY+1)][x-g_HeightPosX-1 ].usHeight ;
		 int s   = g_krgCell[(y-g_HeightPosY+1)][x-g_HeightPosX   ].usHeight ;
         int se  = g_krgCell[(y-g_HeightPosY+1)][x-g_HeightPosX+1 ].usHeight ;  

/*
			 x-1   x    x+1
			+----+----+----+
			| nw | n  | ne |  y-1
			+----+----+----+
			| w  |    | e  |  y
			+----+----+----+
			| sw | s  | se |  y+1
			+----+----+----+
*/
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY-1)][x-g_HeightPosX-1 ].usProperty ) nw = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY-1)][x-g_HeightPosX   ].usProperty ) n = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY-1)][x-g_HeightPosX+1 ].usProperty ) ne = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY  )][x-g_HeightPosX-1 ].usProperty ) w = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY  )][x-g_HeightPosX+1 ].usProperty ) e = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY+1)][x-g_HeightPosX-1 ].usProperty ) sw = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY+1)][x-g_HeightPosX   ].usProperty ) s = iUnreachableHeight ;
		 if( a_iBlockedCell & g_krgCell[(y-g_HeightPosY+1)][x-g_HeightPosX+1 ].usProperty ) se = iUnreachableHeight ;

		 if (tx==x && ty==y) {Route[i]=0;break;}
         if (tx==x && ty <y && n <cul+MH && n >cul-MH) {Route[i]='2';y--;continue;}
		 if (tx >x && ty <y && ne<cul+MH && ne>cul-MH) {Route[i]='3';x++;y--;continue;}
		 if (tx >x && ty==y && e <cul+MH && e >cul-MH) {Route[i]='6';x++;continue;}
		 if (tx >x && ty >y && se<cul+MH && se>cul-MH) {Route[i]='9';x++;y++;continue;}         
		 if (tx==x && ty >y && s <cul+MH && s >cul-MH) {Route[i]='8';y++;continue;}
		 if (tx <x && ty >y && sw<cul+MH && sw>cul-MH) {Route[i]='7';x--;y++;continue;}
		 if (tx <x && ty==y && w <cul+MH && w >cul-MH) {Route[i]='4';x--;continue;}
		 if (tx <x && ty <y && nw<cul+MH && nw>cul-MH) {Route[i]='1';x--;y--;continue;}
         //  최적의 라우팅에 실패했을 경우 2nd Routing을 한다.
		 if (tx >x && ty <y && e<cul+MH && e >cul-MH) {Route[i]='6';x++;continue;}
		 if (tx >x && ty <y && n<cul+MH && n >cul-MH) {Route[i]='2';y--;continue;}
		 if (tx >x && ty >y && e<cul+MH && e >cul-MH) {Route[i]='6';x++;continue;}         
		 if (tx >x && ty >y && s<cul+MH && s >cul-MH) {Route[i]='8';y++;continue;}         
		 if (tx <x && ty >y && w<cul+MH && w >cul-MH) {Route[i]='4';x--;continue;}
		 if (tx <x && ty >y && s<cul+MH && s >cul-MH) {Route[i]='8';y++;continue;}
		 if (tx <x && ty <y && w<cul+MH && w >cul-MH) {Route[i]='4';x--;continue;}
         if (tx <x && ty <y && n<cul+MH && n >cul-MH) {Route[i]='2';y--;continue;}
		 if (tx==x+1||ty==y+1||tx==x-1||ty==y-1) {Route[i]=0;break;}
		 // 추가 라우팅.
         if (tx==x && ty >y && se <cul+MH && se >cul-MH) {Route[i]='9';x++;y++;continue;}         
         if (tx==x && ty >y && sw <cul+MH && sw >cul-MH) {Route[i]='7';x--;y++;continue;}
         if (tx==x && ty <y && ne <cul+MH && ne >cul-MH) {Route[i]='3';x++;y--;continue;}
         if (tx==x && ty <y && nw <cul+MH && nw >cul-MH) {Route[i]='1';x--;y--;continue;}
		 //
		 if (tx <x && ty==y && sw <cul+MH && sw >cul-MH) {Route[i]='7';x--;y++;continue;}
		 if (tx <x && ty==y && nw <cul+MH && nw >cul-MH) {Route[i]='1';x--;y--;continue;}
		 if (tx >x && ty==y && se <cul+MH && se >cul-MH) {Route[i]='9';x++;y++;continue;}         
		 if (tx >x && ty==y && ne <cul+MH && ne >cul-MH) {Route[i]='3';x++;y--;continue;}
		 Route[i]=0;
		 break; 
  
         //길이 없는경우.
	 }
     

     if (lastx==x && lasty==y) return 0;
     {  
        int kk=0;
     }


	 *targetx=x;
	 *targety=y;
     if (lastx==x && lasty==y) return 0;
	 return 1;
}


//   거리가 
int  BASE_GetDistance(int x1,int y1,int x2,int y2)
{   
	int	dx,dy;
	if	(x1>x2) dx = x1 - x2;
	else	dx = x2 - x1;
	if (y1>y2) dy = y1 - y2;
	else       dy = y2 - y1;
	if	(dx<=7 && dy<=7)
	{	return g_pDistanceTable[dy][dx];
	} 
	if (dx>dy) return dx+1;
	else       return dy+1;
	return 0;
}

//void BASE_GetHitPosition(int sx, int sy, int * tx , int  *ty, short** pHeight)
void BASE_GetHitPosition(int sx, int sy, int * tx , int  *ty ) 
{
    int dx,dy,dir;
    int Last;
	int a,b;
 	if (sx==*tx && sy==*ty) return;
	if (sx==0 || sy==0 || *tx==0 || *ty==0) return;
	if (sx>*tx) dx = sx - *tx;
	else        dx = *tx - sx;
	if (sy>*ty) dy = sy - *ty;
	else        dy = *ty - sy;
	int dis =  BASE_GetDistance(sx,sy,*tx,*ty);
	if (dis<=1) return;	 
    int This;// =  pHeight[(sy-g_HeightPosY)*g_HeightWidth+sx-g_HeightPosX];
	if	(dx>dy)
	{	if	((*tx-sx)==0) return;
		a = ((*ty-sy)*1000) / (*tx-sx);
        b = (sy*1000) - (a*sx);
		if (sx < *tx) dir =  1;
		else          dir = -1;
		sx = sx + dir;
		if	(dx==dy)
		{	if (sy < *ty) sy++;
		    else          sy--;
		}
		int ttyp = (a*sx+b);
		int yp = ttyp / 1000;
		//This = pHeight[(yp-g_HeightPosY)*g_HeightWidth+sx-g_HeightPosX];
		This = g_krgCell[yp-g_HeightPosY][sx-g_HeightPosX].usHeight ;
		if	(This==127) {*tx=0;*ty=0;return;}
		int leng=dx;
        for (int x = sx; x!=*tx ;x=x+dir)
		{
			if	(x==sx)  
			{	leng--;
				if	(leng<1) break;
				continue;
			}
			ttyp = (a*x+b);
			yp = ttyp / 1000;
			Last = This;
			#ifdef WYD_CLIENT
			if ( (yp-g_HeightPosY)<0 || (yp-g_HeightPosY)>=256 || (x-g_HeightPosX)<0 || (x-g_HeightPosX)>=256){*tx=0;*ty=0; return;}
			#endif
			//This = pHeight[(yp-g_HeightPosY)*g_HeightWidth+x-g_HeightPosX];
			This = g_krgCell[yp-g_HeightPosY][x-g_HeightPosX].usHeight ;
			if	(This==127) {*tx=0;*ty=0;return;}
			if	(This>Last+MH || This<Last-MH)
			{	*tx=x;*ty=yp;
				return;
			}
			leng--; 
			if (leng<1) break;
		}
	 }	else
	 {	if	((*ty-sy)==0) return;
		a = ((*tx-sx)*1000) / (*ty-sy);
		b = (sx*1000) - (a*sy);
		if (sy < *ty) dir =  1;
		else          dir = -1;
		sy = sy + dir;
		if	(dx==dy)
		{	if (sx < *tx) sx++;
			else          sx--;
		}
		int ttxp = (a*sy+b);
		int xp = ttxp/1000;
		//This = pHeight[(sy-g_HeightPosY)*g_HeightWidth+xp-g_HeightPosX];
		This = g_krgCell[sy-g_HeightPosY][xp-g_HeightPosX].usHeight ;
		if	(This==127) {*tx=0;*ty=0;return;}
		int leng = dy;
		for (int y = sy;y!=*ty;y=y+dir)
		{   
			if	(y==sy) 
			{	leng--;
				if (leng<1) break;
				continue;
			}
			ttxp = (a*y+b);
			xp = ttxp/1000;
			Last = This;
            #ifdef WYD_CLIENT
			if ( (y-g_HeightPosY)<0 || (y-g_HeightPosY)>=256 || (xp-g_HeightPosX)<0 || (xp-g_HeightPosX)>=256){*tx=0;*ty=0; return;}
            #endif
			//This = pHeight[(y-g_HeightPosY)*g_HeightWidth+xp-g_HeightPosX];
			This = g_krgCell[y-g_HeightPosY][xp-g_HeightPosX].usHeight ;
			if	(This==127) {*tx=0;*ty=0;return;}
			if (This>Last+MH || This<Last-MH)
			{  *tx=xp;*ty=y;
			   return;
			}
			leng--; 
			if (leng<1) break;
		}
	}
	return;
}


void BASE_WriteInitItem(void)
{
	int size = sizeof(STRUCT_INITITEM) * MAX_INITITEM;
	char * temp = (char *)g_pInitItem;
	for (int i=0;i<size;i++){temp[i]= temp[i]^0xFF;}  //STRUCT_INITITEM   g_pInitItem[MAX_INITITEM];
	FILE* fp = fopen("InitItem.bin", "wb");
	if	(fp==NULL) {MessageBox(NULL,"Can't write inititem.bin","ERROR",MB_OK|MB_SYSTEMMODAL);return;}
	fwrite(g_pInitItem, size,1, fp);
	fclose(fp);
	for (i=0;i<size;i++){temp[i]= temp[i]^0xFF;}
}

int BASE_ReadInitItem(void)
{
	int size = sizeof(STRUCT_INITITEM) * MAX_INITITEM;
	char * temp = (char *)g_pInitItem;
	FILE* fp = fopen("WYD.EXE","rb");
	if	(fp==NULL) fp = fopen("WYDSC.EXE", "rb");
	if	(fp==NULL) fp = fopen("WYDTC.EXE", "rb");
	if	(fp==NULL) {MessageBox(NULL,"Can't read inititem.bin","ERROR",MB_OK|MB_SYSTEMMODAL);return FALSE;}
	fseek(fp,-size,SEEK_END);
	fread(g_pInitItem, size, 1 , fp);
	fclose(fp);
	for (int i=0;i<size;i++){ temp[i]= temp[i]^0xFF;}

	for(i=0;i<MAX_INITITEM;i++){		
		if(g_pInitItem[i].PosX<=0){
			g_dwInitItem = i;
			break;
		}
	}

	return TRUE;
}


void BASE_InitializeInitItem(void)
{

     FILE * fp  =  fopen("./InitItem.csv","rb");
     if (fp==NULL) fp =fopen("TMSRV/Run/InitItem.csv","rb");
	 if (fp==NULL) {MessageBox(NULL,"There is no file","InitItem.csv",NULL);return;}	

     char str[1024];
     char * ret = fgets((char*)str,1023,fp);
	 if (ret==NULL) return;
     g_dwInitItem=0;
	 while(1)
	 {
		char str[1024];
		char * ret = fgets((char*)str,1024,fp);
		if (ret==NULL) break;     
		for (int i=0;i<1024;i++)
		{   if (str[i]==',') str[i]=' ';
		    if (str[i]==-0) break;
		}
        int Index,PosX,PosY,Rotate;
        Index=-1;PosX=0;PosY=0;Rotate=0;
		sscanf(str,"%d %d %d %d",&Index,&PosX,&PosY,&Rotate);
		if (Index==-1) continue;


        g_pInitItem[g_dwInitItem].PosX=PosX;
        g_pInitItem[g_dwInitItem].PosY=PosY;
        g_pInitItem[g_dwInitItem].nIndex=Index;
        g_pInitItem[g_dwInitItem].Rotate=Rotate;
        g_dwInitItem++;
	 }
	 fclose(fp);
}


void BASE_InitializeSkill(void)
{
     FILE * fp  =  fopen("./SkillData.csv","rb");
     if (fp==NULL) fp =fopen("TMSRV/Run/SkillData.csv","rb");
	 if (fp==NULL) {MessageBox(NULL,"There is no file","SkillData.csv",NULL);return;}	
	 char str[1024];

     memset(g_pSpell,0,sizeof(g_pSpell));
	 char * ret = fgets((char*)str,1024,fp);
	 if (ret==NULL) return;

	 while(1)
	 {
		char * ret = fgets((char*)str,1024,fp);
		if (ret==NULL) break;     
		for (int i=0;i<1024;i++)
		{   if (str[i]==',') str[i]=' ';
		    if (str[i]==-0) break;
		}
		STRUCT_SPELL temp; memset(&temp,0,sizeof(temp));
        int Index = -1;
        char skilldata[256];
		sscanf(str,"%d %d %d %d %d %d %d %d %d %d %d %d %d %s %d %d %d %d %d %d %d", 
								&Index,				&temp.SkillPoint,	&temp.TargetType,	&temp.ManaSpent,	&temp.Delay,
								&temp.Range,		&temp.InstanceType,	&temp.InstanceValue,&temp.TickType,		&temp.TickValue,
								&temp.AffectType,	&temp.AffectValue,	&temp.AffectTime,	skilldata,			&temp.InstanceAttribute,
								&temp.TickAttribute,&temp.Aggressive,	&temp.MaxTarget,	&temp.bParty,		&temp.AffectResist,&temp.Passive);
		if (Index<0 ||Index>=MAX_SKILLINDEX) continue;
		temp.AffectTime = temp.AffectTime / 4;

		temp.Act[0]=0;
		temp.Act[1]=0;
		temp.Act[2]=0;
		temp.Act[3]=0;
		temp.Act[4]=0;
		temp.Act[5]=0;
		temp.Act[6]=0;
		temp.Act[7]=0;

		sscanf(skilldata,"%d.%d.%d.%d.%d.%d",&temp.Act[0],&temp.Act[1],&temp.Act[2],&temp.Act[3],&temp.Act[4],&temp.Act[5]);

		g_pSpell[Index] = temp;
	 }
	 fclose(fp);


	 return;
}

int IsClearString3(char* str, int nTarget)
{	if(str==NULL) return TRUE;
	char*	pNextRightChar	= CharNext(&str[nTarget]);
	if	(str+nTarget+1!=pNextRightChar) return FALSE;
	return TRUE;
}

BOOL  BASE_InitializeServerList(void)
{

	FILE *fp = fopen("./serverlist.txt","rt");
	if ( fp != NULL )
	{
		memset(g_pServerList,0,sizeof(g_pServerList));

		char str[256];
		char address[64];
		int ServerGroup;
		int ServerNumber;
		int port;
		while(1)
		{
		  char * ret = fgets((char*)str,255,fp);
		  if (ret==NULL){			
			//return TRUE;
			  break;
		  }
		  ServerGroup=-1;
		  ServerNumber=-1;
		  address[0]=0;
		  port=0;
		  sscanf(str,"%d %d %s %d",&ServerGroup,&ServerNumber,address,&port);
		  if (ServerGroup<0||ServerGroup>=MAX_SERVERGROUP||ServerNumber<0||ServerNumber>=MAX_SERVERNUMBER){
			  break;
		  }
			strcpy(g_pServerList[ServerGroup][ServerNumber],address);
			unsigned r1,r2,r3,r4;sscanf(address,"%d.%d.%d.%d",&r1,&r2,&r3,&r4);
			g_pServerListPort[ServerGroup][ServerNumber] = port;
			g_pServerListBin[ServerGroup][ServerNumber] = (r1) | (r2<<8) | (r3<<16) | (r4<<24);
		}
		fclose(fp);
		
		// Encoding
		FILE* fpBin = fopen("./serverlist.bin", "wb");
		if(fpBin!=NULL){
			char szServerBin[64];
			char szList[65] ="ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣㅏㅔㅣㅗㅜ가나다";
			for(int k=0;k<MAX_SERVERGROUP;k++)
				for(int j=0;j<MAX_SERVERNUMBER;j++)
				{	sprintf( szServerBin, "%s:%d", g_pServerList[k][j], g_pServerListPort[k][j] );
					for(int i=0;i<64;i++) 
					{	szServerBin[i] += szList[63 - i];
					}
					fwrite( szServerBin, 1, 64, fpBin );
				}
			fclose(fpBin);
		}		
	}
	else
	{
		FILE* fpBin = fopen("./serverlist.bin", "rb");
		if(fpBin!=NULL){
			char szServerBin[64];
			char szList[65] ="ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣㅏㅔㅣㅗㅜ가나다";			

			for(int k=0;k<MAX_SERVERGROUP;k++)
				for(int j=0;j<MAX_SERVERNUMBER;j++)
				{
					fread( szServerBin, 1, 64, fpBin );
					for(int i=0;i<64;i++) 
					{
						szServerBin[i] -= szList[63 - i];
					}
					unsigned r1,r2,r3,r4;
					sscanf( szServerBin, "%d.%d.%d.%d:%d", &r1,&r2,&r3,&r4,&g_pServerListPort[k][j] );
					sprintf( g_pServerList[k][j], "%d.%d.%d.%d", r1,r2,r3,r4 );
				}
			fclose(fpBin);
		}
	}
	return TRUE;	 
}

BOOL  BASE_InitializeServerList_Client(int *pTest, int *pCountryCode)
{

	FILE *fp = fopen("./serverlist.txt","rt");
	if ( fp != NULL )
	{
		memset(g_pServerList,0,sizeof(g_pServerList));

		char str[256];
		char address[64];
		int ServerGroup;
		int ServerNumber;
		int port;

		char * ret = fgets((char*)str,255,fp);
		if (ret==NULL)
		{
			fclose(fp);
			return TRUE;
		}
		sscanf(str,"%d %d",pTest, pCountryCode);

		while(1)
		{
		  char * ret = fgets((char*)str,255,fp);
		  if (ret==NULL){			
			//return TRUE;
			  break;
		  }
		  ServerGroup=-1;
		  ServerNumber=-1;
		  address[0]=0;
		  port=0;
		  sscanf(str,"%d %d %s %d",&ServerGroup,&ServerNumber,address,&port);
		  if (ServerGroup<0||ServerGroup>=MAX_SERVERGROUP||ServerNumber<0||ServerNumber>=MAX_SERVERNUMBER){
			  break;
		  }
			strcpy(g_pServerList[ServerGroup][ServerNumber],address);
			unsigned r1,r2,r3,r4;sscanf(address,"%d.%d.%d.%d",&r1,&r2,&r3,&r4);
			g_pServerListPort[ServerGroup][ServerNumber] = port;
			g_pServerListBin[ServerGroup][ServerNumber] = (r1) | (r2<<8) | (r3<<16) | (r4<<24);
		}
		fclose(fp);
		
		// Encoding
		FILE* fpBin = fopen("./serverlist.bin", "wb");
		if(fpBin!=NULL){
			char szServerBin[64];
			char szList[65] ="ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣㅏㅔㅣㅗㅜ가나다";
			sprintf(szServerBin, "%d %d", *pTest, *pCountryCode );
			for(int i=0;i<64;i++)
			{	szServerBin[i] += szList[63 - i];
			}
			fwrite( szServerBin, 1, 64, fpBin );
			for(int k=0;k<MAX_SERVERGROUP;k++)
				for(int j=0;j<MAX_SERVERNUMBER;j++)
				{	sprintf( szServerBin, "%s:%d", g_pServerList[k][j], g_pServerListPort[k][j] );
					for(int i=0;i<64;i++) 
					{	szServerBin[i] += szList[63 - i];
					}
					fwrite( szServerBin, 1, 64, fpBin );
				}
			fclose(fpBin);
		}		
	}
	else
	{
		FILE* fpBin = fopen("./serverlist.bin", "rb");
		if(fpBin!=NULL){
			char szServerBin[64];
			char szList[65] ="ㄱㄴㄷㄹㅁㅂㅅㅇㅈㅊㅋㅌㅍㅎㅏㅑㅓㅕㅗㅛㅜㅠㅡㅣㅏㅔㅣㅗㅜ가나다";
			fread( szServerBin, 1, 64, fpBin );
			for(int i=0;i<64;i++)
			{
				szServerBin[i] -= szList[63 - i];
			}
			sscanf(szServerBin,"%d %d",pTest,pCountryCode);
			for(int k=0;k<MAX_SERVERGROUP;k++)
				for(int j=0;j<MAX_SERVERNUMBER;j++)
				{
					fread( szServerBin, 1, 64, fpBin );
					for(int i=0;i<64;i++) 
					{
						szServerBin[i] -= szList[63 - i];
					}
					unsigned r1,r2,r3,r4;
					sscanf( szServerBin, "%d.%d.%d.%d:%d", &r1,&r2,&r3,&r4,&g_pServerListPort[k][j] );
					sprintf( g_pServerList[k][j], "%d.%d.%d.%d", r1,r2,r3,r4 );
				}
			fclose(fpBin);
		}
	}
	return TRUE;	 
}

#pragma pack(push, 1)
typedef struct _CELL_INFO
{
	WORD wX;
	WORD wZ;
	BYTE byCount;
} CELL_INFO;
typedef struct _CELL_STATUS
{//fors_debug 唐rem돨뒈렘떼角쥼棍rem돨
	BYTE	byFloor;		// Cell 층
	WORD	wHeight;		// Cell 단
	WORD	wObjHeight;		// Cell 위에 존재하는 맵오브젝트의 높이
	BYTE	byFeature;		// 지형 유형

	WORD	wState;			// Cell 및 맵오브젝트의 상태정보
	DWORD	dwEvent;		// 이벤트 번호
	DWORD	dwReserved;		// 예약
} CELL_STATUS;
struct MAP_FILE_HEADER
{
	char	szVersion	[HEADER_VERSION_SIZE];
	char	szUpdateDate[HEADER_UPDATE_SIZE];	//	For test;
	int		nDataCount;
	char	szMapName	[_MAP_MANAGER::NAME_LEN];
	WORD	wMapIndex;
	BYTE	byPKInfo;
	WORD	wMapX;
	WORD	wMapY;
	WORD	TrimuritiZone;
	SHORT	TrimuritiStartX;
	SHORT	TrimuritiStartZ;
	SHORT	TrimuritiEndX;
	SHORT	TrimuritiEndZ;
	DWORD	dwFloorCountTotal;
};
#pragma pack(pop)


//-------------------------------------------------------------------------------------
// 맵 데이터 로딩
//-------------------------------------------------------------------------------------
int BASE_InitializeAttribute(E_COUNTRY_ID contry) // reading g_pAttribute
{
#ifdef __ZONE_SERVER__
	g_kInfluenceMap.Init() ;

	FILE * fp = NULL;

	//	if(contry == eCountryKorea) fp = fopen("Attribute.dat","rb");
//fors_debug map skip 뒈暠뗍혤
	
	if	(fp==NULL)	
	{	fp = fopen("MapData.tcm","rb");
		if	(fp==NULL) {MessageBox(NULL,"can't file MapData.tcm file","error",MB_OK|MB_SYSTEMMODAL); return FALSE;}
		//
		MAP_FILE_HEADER header; fread(&header,sizeof(header),1,fp);

		CELL_STATUS status[10];
		CELL_INFO info;

		for	(DWORD dwIndex=0;dwIndex<header.dwFloorCountTotal;dwIndex++)
		{	
			fread(&info,sizeof(CELL_INFO),1,fp);
			fread(status,sizeof(CELL_STATUS),info.byCount,fp );
//fors_debug 꿎桿와빵똥뒈暠痰륩蛟똥
			g_krgCell[info.wZ][info.wX].usHeight = status[0].wHeight ;
//
		   // if(contry == eCountryKorea)  //fors_debug map_cell
		//	  g_krgCell[info.wZ][info.wX].usProperty = status[0].wState ;
		//	else
              g_krgCell[info.wZ][info.wX].usProperty = status[0].wState ;
//fors_debug 꿎桿와빵똥뒈暠痰륩蛟똥

			g_krgCell[info.wZ][info.wX].usEvent = (short)status[0].dwEvent ;
			if( 0 < g_krgCell[info.wZ][info.wX].usEvent && eEvent_MaxCount > g_krgCell[info.wZ][info.wX].usEvent )
				g_krgCell[info.wZ][info.wX].usProperty = g_krgCell[info.wZ][info.wX].usProperty | eTNCell_HaveEvent ; 
		}
		return TRUE;
	}
	else
		fread( g_krgCell, sizeof(g_krgCell), 1, fp ) ;

	for( int y = 0 ; y < MAX_GRIDY ; ++y )
	{
		for( int x = 0 ; x < MAX_GRIDX ; ++x )
		{ //fors_debug 뒈暠 too
	  	if( eTNCell_SafetyZone & g_krgCell[y][x].usProperty ) g_kInfluenceMap.PropagteInfl( x, y, TNInfluenceMap::eInfl_SaftyZone ) ;
			else if( eTNCell_Blocked & g_krgCell[y][x].usProperty ) g_kInfluenceMap.PropagteInfl( x, y, TNInfluenceMap::eInfl_Forbidden, 0 ) ; 
		}
	}

	fclose( fp ) ;
#endif //__ZONE_SERVER__
	return TRUE;
}

BOOL BASE_GetHttpRequest(char * httpname,char * Request,int MaxBuffer)
{
  #ifdef WYD_CLIENT
	DWORD dwBytesRead;
	HINTERNET m_Session;
	m_Session = InternetOpen("MS",INTERNET_OPEN_TYPE_PRECONFIG,  // Use registry settings. 
							 NULL,					        // Proxy name. NULL indicates use default.
							 NULL,                          // List of local servers. NULL indicates default. 
							 0) ;
	HINTERNET hHttpFile;
	hHttpFile = InternetOpenUrl(m_Session, (const char *) httpname, NULL, 0, INTERNET_FLAG_NO_CACHE_WRITE , 0);
	if (hHttpFile)
	{  InternetReadFile(hHttpFile, Request, MaxBuffer, &dwBytesRead); 
	   InternetCloseHandle(hHttpFile);
	   Request[dwBytesRead]=0;
	}  else
	{  int ret=GetLastError();
       return FALSE;
	}
  #endif

	return TRUE;
}


int BASE_GetEnglish(char *name)
{
	char temp[256];
	strcpy(temp,name);
    
	for (int i=0;i<MAX_ENGLISH;i++)
	{
		if (!strcmp(name,g_pEnglish[i][0]))
		{  strcpy(name,  g_pEnglish[i][2]);
		   return TRUE;
		}
	}
    return FALSE;
}


BOOL BASE_CheckPacket(MSG_STANDARD *m)
{	if (m==NULL) return 0;
	int code =0;
/*
	if	(m->Type==  _MSG_MessagePanel				&& m->Size != sizeof( MSG_MessagePanel			))code = 1;
	if	(m->Type==  _MSG_MessageBoxOk 				&& m->Size != sizeof( MSG_MessageBoxOk 			))code = 1;
	if	(m->Type==  _MSG_CNFMessageBoxOk			&& m->Size != sizeof( MSG_CNFMessageBoxOk		))code = 1;
	if	(m->Type==  _MSG_MessageBoxYesNo 			&& m->Size != sizeof( MSG_MessageBoxYesNo 		))code = 1;
	if	(m->Type==  _MSG_NewAccount   				&& m->Size != sizeof( MSG_NewAccount   			))code = 1;
	if	(m->Type==  _MSG_AccountLogin   			&& m->Size != sizeof( MSG_AccountLogin   		))code = 1;
	if	(m->Type==  _MSG_CNFAccountLogin 			&& m->Size != sizeof( MSG_CNFAccountLogin 		))code = 1;
	if	(m->Type==  _MSG_NewCharacter				&& m->Size != sizeof( MSG_NewCharacter			))code = 1;
	if	(m->Type==  _MSG_CNFNewCharacter			&& m->Size != sizeof( MSG_CNFNewCharacter		))code = 1;
	if	(m->Type==  _MSG_DeleteCharacter			&& m->Size != sizeof( MSG_DeleteCharacter		))code = 1;
	if	(m->Type==  _MSG_CNFDeleteCharacter 		&& m->Size != sizeof( MSG_CNFDeleteCharacter 	))code = 1;
	if	(m->Type==  _MSG_CharacterLogin  			&& m->Size != sizeof( MSG_CharacterLogin  		))code = 1;
	if	(m->Type==  _MSG_CNFCharacterLogin 			&& m->Size != sizeof( MSG_CNFCharacterLogin 	))code = 1;
	if	(m->Type==  _MSG_CNFCharacterLogout 		&& m->Size != sizeof( MSG_STANDARD 				))code = 1;
	if	(m->Type==  _MSG_NewAccountFail    			&& m->Size != sizeof( MSG_STANDARD    			))code = 1;
//	if	(m->Type==  _MSG_AccountLoginFail			&& m->Size != sizeof( MSG_AccountLoginFail  	))code = 1;  //_MSG_DBAccountLoginFail_Account,Pass,AlreadyPlaying으로 지원
	if	(m->Type==  _MSG_CharacterLoginFail			&& m->Size != sizeof( MSG_STANDARD  			))code = 1;
	if	(m->Type==  _MSG_NewCharacterFail   		&& m->Size != sizeof( MSG_STANDARD   			))code = 1;
	if	(m->Type==  _MSG_DeleteCharacterFail		&& m->Size != sizeof( MSG_STANDARD 				))code = 1;
	if	(m->Type==  _MSG_AlreadyPlaying   			&& m->Size != sizeof( MSG_STANDARD   			))code = 1;
	if	(m->Type==  _MSG_StillPlaying   			&& m->Size != sizeof( MSG_STANDARD   			))code = 1;
	if	(m->Type==  _MSG_MessageChat   				&& m->Size != sizeof( MSG_MessageChat   		))code = 1;
	if	(m->Type==  _MSG_MessageWhisper				&& m->Size != sizeof( MSG_MessageWhisper		))code = 1;
	if	(m->Type==  _MSG_UpdateScore  				&& m->Size != sizeof( MSG_UpdateScore  			))code = 1;
	if	(m->Type==  _MSG_UpdateEtc					&& m->Size != sizeof( MSG_UpdateEtc				))code = 1;
	if	(m->Type==  _MSG_CNFMobKill   				&& m->Size != sizeof( MSG_CNFMobKill   			))code = 1;
	if	(m->Type==  _MSG_CreateMob  				&& m->Size != sizeof( MSG_CreateMob  			))code = 1;
	if	(m->Type==  _MSG_RemoveMob					&& m->Size != sizeof( MSG_RemoveMob				))code = 1;
	if	(m->Type==  _MSG_Action						&& m->Size != sizeof( MSG_Action				))code = 1;
	if	(m->Type==  _MSG_REQMobByID					&& m->Size != sizeof( MSG_REQMobByID			))code = 1;
	if	(m->Type==  _MSG_Motion    					&& m->Size != sizeof( MSG_Motion    			))code = 1;
	if	(m->Type==  _MSG_UpdateEquip				&& m->Size != sizeof( MSG_UpdateEquip			))code = 1;
	if	(m->Type==  _MSG_Attack						&& m->Size != sizeof( MSG_Attack				))code = 1;
	if	(m->Type==  _MSG_Stop          				&& m->Size != sizeof( MSG_Action          		))code = 1;
	if	(m->Type==  _MSG_CreateItem   				&& m->Size != sizeof( MSG_CreateItem   			))code = 1;
	if	(m->Type==  _MSG_RemoveItem					&& m->Size != sizeof( MSG_RemoveItem			))code = 1;
	if	(m->Type==  _MSG_GetItem					&& m->Size != sizeof( MSG_GetItem				))code = 1;
	if	(m->Type==  _MSG_CNFGetItem					&& m->Size != sizeof( MSG_CNFGetItem			))code = 1;
	if	(m->Type==  _MSG_DropItem 					&& m->Size != sizeof( MSG_DropItem 				))code = 1;
	if	(m->Type==  _MSG_UseItem					&& m->Size != sizeof( MSG_UseItem				))code = 1;
	if	(m->Type==  _MSG_UpdateItem 				&& m->Size != sizeof( MSG_UpdateItem 			))code = 1;
	if	(m->Type==  _MSG_CNFDropItem 				&& m->Size != sizeof( MSG_CNFDropItem 			))code = 1;
	if	(m->Type==  _MSG_SwapItem					&& m->Size != sizeof( MSG_SwapItem				))code = 1;
	if	(m->Type==  _MSG_ApplyBonus					&& m->Size != sizeof( MSG_ApplyBonus			))code = 1;
	if	(m->Type==  _MSG_SetShortSkill				&& m->Size != sizeof( MSG_SetShortSkill			))code = 1;
	if	(m->Type==  _MSG_Buy						&& m->Size != sizeof( MSG_Buy					))code = 1;
	if	(m->Type==  _MSG_Sell						&& m->Size != sizeof( MSG_Sell					))code = 1;
	if	(m->Type==  _MSG_REQShopList				&& m->Size != sizeof( MSG_REQShopList			))code = 1;
	if	(m->Type==  _MSG_ShopList					&& m->Size != sizeof( MSG_ShopList				))code = 1;
	if	(m->Type==  _MSG_AddParty					&& m->Size != sizeof( MSG_AddParty				))code = 1;
	if	(m->Type==  _MSG_RemoveParty				&& m->Size != sizeof( MSG_RemoveParty			))code = 1;
	if	(m->Type==  _MSG_REQParty					&& m->Size != sizeof( MSG_REQParty				))code = 1;
	if	(m->Type==  _MSG_CNFParty					&& m->Size != sizeof( MSG_CNFParty				))code = 1;
	if	(m->Type==  _MSG_SetHpMp					&& m->Size != sizeof( MSG_SetHpMp				))code = 1;
	if	(m->Type==  _MSG_SendItem					&& m->Size != sizeof( MSG_SendItem				))code = 1;
	if	(m->Type==  _MSG_Trade						&& m->Size != sizeof( MSG_Trade					))code = 1;
	if	(m->Type==  _MSG_QuitTrade					&& m->Size != sizeof( MSG_STANDARD				))code = 1;
	if	(m->Type==  _MSG_Inven						&& m->Size != sizeof( MSG_Inven					))code = 1;
	if	(m->Type==  _MSG_CNFCheck					&& m->Size != sizeof( MSG_STANDARD				))code = 1;
	if	(m->Type==  _MSG_Withdraw        			&& m->Size != sizeof( MSG_STANDARDPARM        	))code = 1;
	if	(m->Type==  _MSG_Deposit					&& m->Size != sizeof( MSG_STANDARDPARM			))code = 1;
	if	(m->Type==  _MSG_Restart					&& m->Size != sizeof( MSG_STANDARD 				))code = 1;
	if	(m->Type==  _MSG_SetHpDam					&& m->Size != sizeof( MSG_SetHpDam				))code = 1;
	if	(m->Type==  _MSG_Weather          			&& m->Size != sizeof( MSG_STANDARDPARM          ))code = 1;
	if	(m->Type==  _MSG_Quest             			&& m->Size != sizeof( MSG_STANDARDPARM2         ))code = 1;
	if	(m->Type==  _MSG_Deprivate        			&& m->Size != sizeof( MSG_STANDARDPARM       	))code = 1;
	if	(m->Type==  _MSG_ReqChallange       		&& m->Size != sizeof( MSG_STANDARD       		))code = 1;
	if	(m->Type==  _MSG_Challange        			&& m->Size != sizeof( MSG_STANDARDPARM        	))code = 1;
	if	(m->Type==  _MSG_ChallangeConfirm  			&& m->Size != sizeof( MSG_STANDARDPARM2  		))code = 1;
	if	(m->Type==  _MSG_ReqTeleport       			&& m->Size != sizeof( MSG_STANDARDPARM       	))code = 1;
	if	(m->Type==  _MSG_EnterVillage      			&& m->Size != sizeof( MSG_STANDARDPARM          ))code = 1;
	if	(m->Type==  _MSG_SetHpMode           		&& m->Size != sizeof( MSG_STANDARDPARM          ))code = 1;
	if	(m->Type==  _MSG_SetClan             		&& m->Size != sizeof( MSG_STANDARDPARM          ))code = 1;
	if	(m->Type==  _MSG_BillingPage				&& m->Size != sizeof( MSG_STANDARDPARM          ))code = 1;
	if	(m->Type==  _MSG_Imple						&& m->Size != sizeof( MSG_MessageWhisper        ))code = 1;
	if	(m->Type==  _MSG_DBMessagePanel				&& m->Size != sizeof( MSG_MessagePanel			))code = 1;
	if	(m->Type==  _MSG_DBMessageBoxOk				&& m->Size != sizeof( MSG_MessageBoxOk       	))code = 1;
	if	(m->Type==  _MSG_DBMessageBoxYesNo			&& m->Size != sizeof( MSG_MessageBoxYesNo    	))code = 1;
	if	(m->Type==  _MSG_DBCloseNothing				&& m->Size != sizeof( MSG_STANDARD       	    ))code = 1;
	if	(m->Type==  SSP_REQ_SAVE_QUIT				&& m->Size != sizeof( S_SSP_REQ_SAVE_QUIT      	))code = 1;
	if	(m->Type==  SSP_RESP_SAVE_QUIT				&& m->Size != sizeof( MSG_STANDARD      	    ))code = 1;
//	if	(m->Type==  _MSG_DBCNFNewAccount			&& m->Size != sizeof( MSG_DBCNFNewAccount		))code = 1; // 웹에서만지원
	if	(m->Type==  _MSG_DBCNFAccountLogin			&& m->Size != sizeof( MSG_CNFAccountLogin    	))code = 1;
	if	(m->Type==  _MSG_DBCNFCharacterLogin		&& m->Size != sizeof( MSG_CNFCharacterLogin  	))code = 1;
	if	(m->Type==  _MSG_DBCNFNewCharacter			&& m->Size != sizeof( MSG_CNFNewCharacter    	))code = 1;
	if	(m->Type==  _MSG_DBCNFDeleteCharacter		&& m->Size != sizeof( MSG_CNFDeleteCharacter 	))code = 1;
	if	(m->Type==  _MSG_DBNewAccountFail			&& m->Size != sizeof( MSG_STANDARD     	        ))code = 1;
	if	(m->Type==  _MSG_DBAccountLoginFail			&& m->Size != sizeof( MSG_STANDARD   	        ))code = 1;
	if	(m->Type==  _MSG_DBCharacterLoginFail		&& m->Size != sizeof( MSG_STANDARD 	            ))code = 1;
	if	(m->Type==  _MSG_DBNewCharacterFail			&& m->Size != sizeof( MSG_STANDARD   	        ))code = 1;
	if	(m->Type==  _MSG_DBDeleteCharacterFail		&& m->Size != sizeof( 	  MSG_STANDARD          ))code = 1;
	if	(m->Type==  _MSG_DBAlreadyPlaying			&& m->Size != sizeof( MSG_STANDARD 	            ))code = 1;
	if	(m->Type==  _MSG_DBStillPlaying				&& m->Size != sizeof( MSG_STANDARD   	        ))code = 1;
	if	(m->Type==  _MSG_DBAccountLoginFail_Account && m->Size != sizeof( MSG_STANDARD				))code = 1;
	if	(m->Type==  _MSG_DBAccountLoginFail_Pass    && m->Size != sizeof( MSG_STANDARD				))code = 1;
	if	(m->Type==  _MSG_DBSetIndex					&& m->Size != sizeof( MSG_STANDARDPARM3			))code = 1;
	if	(m->Type==  _MSG_DBAccountLoginFail_Block	&& m->Size != sizeof( MSG_STANDARD				))code = 1;
	if	(m->Type==  _MSG_DBAccountLoginFail_Disable	&& m->Size != sizeof( MSG_STANDARD				))code = 1;
	if	(m->Type==  _MSG_DBNewAccount				&& m->Size != sizeof(MSG_NewAccount				))code = 1;
	if	(m->Type==  _MSG_DBNewCharacter				&& m->Size != sizeof(MSG_NewCharacter     		))code = 1;
	if	(m->Type==  _MSG_DBAccountLogin				&& m->Size != sizeof(MSG_AccountLogin     		))code = 1;
	if	(m->Type==  _MSG_DBCharacterLogin			&& m->Size != sizeof(MSG_CharacterLogin			))code = 1;
	if	(m->Type==  _MSG_DBNoNeedSave          		&& m->Size != sizeof(MSG_STANDARD       		))code = 1;
	if	(m->Type==  _MSG_DBSaveMob             		&& m->Size != sizeof(MSG_DBSaveMob				))code = 1;
//	if	(m->Type==  _MSG_DBDeleteAccount       		&& m->Size != sizeof(MSG_DeleteAccount    		))code = 1; // 웹에서만지원
	if	(m->Type==  _MSG_DBDeleteCharacter     		&& m->Size != sizeof(MSG_DeleteCharacter		))code = 1;
	if	(m->Type==  _MSG_NPReqIDPASS           		&& m->Size != sizeof(MSG_NPIDPASS        		))code = 1;
	if	(m->Type==  _MSG_NPIDPASS              		&& m->Size != sizeof(MSG_NPIDPASS           	))code = 1;
	if	(m->Type==  _MSG_NPReqAccount          		&& m->Size != sizeof(MSG_NPReqAccount       	))code = 1;
	if	(m->Type==  _MSG_NPNotFound            		&& m->Size != sizeof(MSG_STANDARD         		))code = 1;
	if	(m->Type==  _MSG_NPAccountInfo         		&& m->Size != sizeof(MSG_NPAccountInfo      	))code = 1;
	if	(m->Type==  _MSG_NPReqSaveAccount      		&& m->Size != sizeof(MSG_NPAccountInfo   		))code = 1;
	if	(m->Type==  _MSG_NPDisable             		&& m->Size != sizeof(MSG_NPEnable          		))code = 1;
	if	(m->Type==  _MSG_NPEnable              		&& m->Size != sizeof(MSG_NPEnable           	))code = 1;
	if	(m->Type==  _MSG_NPNotice              		&& m->Size != sizeof(MSG_NPNotice				))code = 1;
	if	(m->Type==  _MSG_NPState               		&& m->Size != sizeof(MSG_STANDARDPARM			))code = 1;
	if	(m->Type==  _MSG_War						&& m->Size != sizeof(MSG_STANDARDPARM2			))code = 1;
	if	(m->Type==	_MSG_ReqTransper				&& m->Size != sizeof(MSG_ReqTransper			))code = 1;
	*/
	return code;
}

//	nUserID = nID
//	byPosition(array index)
bool BASE_GetKey(int nUserID , BYTE byPlace, BYTE byPosition, int& nKey)
{
	bool bRet = true;
	nKey = 0;

	if(nUserID<=0 || nUserID>MAX_USER || byPosition<0) return false;
	if(byPlace == ITEM_PLACE_CARGO  && byPosition>=MAX_CARGO) return false;
	if(byPlace == ITEM_PLACE_INVEN  && byPosition>=MAX_INVEN) return false; 
	if(byPlace == ITEM_PLACE_EQUIP  && byPosition>=MAX_EQUIP) return false;

	nKey = nUserID<<16;
	nKey |= byPlace<<8;
	nKey |= byPosition;

	return true;
}

BYTE BASE_GetRefineVariable(STRUCT_ITEM * pRef)
{
	//	아이템의 보조재료중 우선순위를 찾아 리턴한다.
	//	속성		: 불(192), 얼금(128), 독(64), 전기(0)	BYTE의 상위 2개 bit를 이용.
	//	속성수치    : 하위 6개 bit이용한다.

	BYTE byFlag=0; int nFire=0; int nCold=0; int nPoison=0; int nLight=0;

	short	snSour = (pRef->snIndex)+HT_PARAMTYPE_ITEM_START-1; 

	for(int n=0; n<MAX_SUBMATERIAL; n++)
	{
		if(snSour == 6601)	//	라가마니
		{	nFire++;
		}	else
		if(snSour == 6602)	//	닐라마니
		{	nCold++;
		}	else
		if(snSour == 6603)	//	비사잔
		{	nPoison++;
		}	else
		if(snSour == 6604)	//	루바티
		{	nLight++;
		}
	}

	int nMax = nFire;
	if(nMax < nCold) nMax = nCold;
	if(nMax < nPoison) nMax = nPoison;
	if(nMax < nLight) nMax = nLight;

	if(nMax == 0) return 0;

	if(nMax == nFire) return 192 | nMax;
	if(nMax == nCold) return 128 | nMax;
	if(nMax == nPoison) return 64 | nMax;
	if(nMax == nLight) return 0 | nMax;

	return 0;
}

#ifdef __ZONE_SERVER__
	#include "HTNew_On.h"
#endif //__ZONE_SERVER__